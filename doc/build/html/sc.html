

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>tb.sc &mdash; tb 0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="tb 0.1 documentation" href="index.html" />
    <link rel="next" title="tb.sc.core" href="sc.core.html" />
    <link rel="prev" title="tb.misc" href="misc.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="sc.core.html" title="tb.sc.core"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="misc.html" title="tb.misc"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">tb 0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="tb-sc">
<h1>tb.sc<a class="headerlink" href="#tb-sc" title="Permalink to this headline">¶</a></h1>
<p>Submodules:</p>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="sc.core.html">tb.sc.core</a></li>
<li class="toctree-l1"><a class="reference internal" href="sc.dist.html">tb.sc.dist</a></li>
<li class="toctree-l1"><a class="reference internal" href="sc.pos.html">tb.sc.pos</a></li>
<li class="toctree-l1"><a class="reference internal" href="sc.shells.html">tb.sc.shells</a></li>
</ul>
</div>
<span class="target" id="module-tb.sc"></span><p>Package to define tight binding supercells and calculate their tight binding
matrices (hamiltonians) in site-occupation basis. Start by creating an instance
of the <a class="reference internal" href="#tb.sc.SuperCell" title="tb.sc.SuperCell"><tt class="xref py py-class docutils literal"><span class="pre">SuperCell</span></tt></a> class. The methods <a class="reference internal" href="#tb.sc.SuperCell.add_scnn" title="tb.sc.SuperCell.add_scnn"><tt class="xref py py-meth docutils literal"><span class="pre">SuperCell.add_scnn()</span></tt></a>
and <a class="reference internal" href="#tb.sc.SuperCell.add_fccnn" title="tb.sc.SuperCell.add_fccnn"><tt class="xref py py-meth docutils literal"><span class="pre">SuperCell.add_fccnn()</span></tt></a> (and others) give good examples of how to
define lattices within the supercell.</p>
<p>The submodule <a class="reference internal" href="sc.dist.html#module-tb.sc.dist" title="tb.sc.dist"><tt class="xref py py-mod docutils literal"><span class="pre">tb.sc.dist</span></tt></a> contains everything needed to generate random
numbers from various probability distributions, including a few predefined
distributions.</p>
<div class="section" id="classes">
<h2>Classes<a class="headerlink" href="#classes" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="tb.sc.SuperCellObject">
<em class="property">class </em><tt class="descclassname">tb.sc.</tt><tt class="descname">SuperCellObject</tt><a class="reference internal" href="_modules/tb/sc.html#SuperCellObject"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.SuperCellObject" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract base class for almost all other classes defined in this module.
There are certain methods that are shared by all classes used to define
the supercell, so to avoid redundancy, those methods are collected here in
this abstract base class.</p>
<dl class="method">
<dt id="tb.sc.SuperCellObject.evalmath">
<tt class="descname">evalmath</tt><big>(</big><em>value</em>, <em>dtype=&lt;type 'float'&gt;</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#SuperCellObject.evalmath"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.SuperCellObject.evalmath" title="Permalink to this definition">¶</a></dt>
<dd><p>Cast <em>value</em> to the given data type <em>dtype</em>. If value is a string,
assume that it contains a mathematical expression, and evaluate it with
<a class="reference external" href="http://docs.python.org/library/functions.html#eval" title="(in Python v2.7)"><tt class="xref py py-func docutils literal"><span class="pre">eval()</span></tt></a> before casting it to the specified type. Functions are
passed unmodified.</p>
<p>The function could always use <a class="reference external" href="http://docs.python.org/library/functions.html#eval" title="(in Python v2.7)"><tt class="xref py py-func docutils literal"><span class="pre">eval()</span></tt></a>, but this is assumed to be
slower for values that do not have to be evaluated.</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.SuperCellObject.infertype">
<tt class="descname">infertype</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/tb/sc.html#SuperCellObject.infertype"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.SuperCellObject.infertype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return data type (complex or float) that is needed due to the
defined potentials and hoppings within this object. Depends on the
method <tt class="xref py py-meth docutils literal"><span class="pre">is_complex()</span></tt> that is expected to be defined in each
child class.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="tb.sc.SuperCellObject.ismath">
<em class="property">static </em><tt class="descname">ismath</tt><big>(</big><em>string</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#SuperCellObject.ismath"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.SuperCellObject.ismath" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the given string is a mathematical expression (containing
only mathematical operators like &#8216;+&#8217;, &#8216;-&#8216;, &#8216;*&#8217;, or &#8216;/&#8217;, and of course
digits). Can be used before using <a class="reference external" href="http://docs.python.org/library/functions.html#eval" title="(in Python v2.7)"><tt class="xref py py-func docutils literal"><span class="pre">eval()</span></tt></a> on some string to
evaluate a given expression.</p>
<p>Note: This function does not check if the numerical expression is
actually valid. It just gives a hint if the given string should be
passed to <a class="reference external" href="http://docs.python.org/library/functions.html#eval" title="(in Python v2.7)"><tt class="xref py py-func docutils literal"><span class="pre">eval()</span></tt></a> or not.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tb.sc.SuperCell">
<em class="property">class </em><tt class="descclassname">tb.sc.</tt><tt class="descname">SuperCell</tt><big>(</big><em>dim=1</em>, <em>margin=None</em>, <em>label=None</em>, <em>sites=None</em>, <em>lats=None</em>, <em>hops=None</em>, <em>eps=0.1</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#SuperCell"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.SuperCell" title="Permalink to this definition">¶</a></dt>
<dd><p>Define tight binding supercell, using an object-oriented user interface.
Create multiple sites or whole lattices of sites (repeat sites within a
given unitcell periodically). Each site may hold several entities
(potentials).</p>
<dl class="method">
<dt id="tb.sc.SuperCell.add_andheis">
<tt class="descname">add_andheis</tt><big>(</big><em>pot=0.0</em>, <em>hop=-1.0</em>, <em>coup=1.0</em>, <em>mom=1.0</em>, <em>mix=0.1</em>, <em>shape=None</em>, <em>bcond=None</em>, <em>origin=None</em>, <em>bvects=None</em>, <em>label=None</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#SuperCell.add_andheis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.SuperCell.add_andheis" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement Anderson-Heisenberg model with classical impurity spins.
This is the isotropic version, where all spin directions have equal
probability (SU2-invariant).</p>
<dl class="docutils">
<dt>coup</dt>
<dd>exchange couplings J between conduction electrons and local
magnetic moments</dd>
<dt>mom</dt>
<dd>magnetic moment of each impurity</dd>
<dt>mix</dt>
<dd>impurity concentration</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tb.sc.SuperCell.add_andheisp">
<tt class="descname">add_andheisp</tt><big>(</big><em>pot=0.0</em>, <em>hop=-1.0</em>, <em>coup=1.0</em>, <em>mom=1.0</em>, <em>mix=0.1</em>, <em>shape=None</em>, <em>bcond=None</em>, <em>origin=None</em>, <em>bvects=None</em>, <em>label=None</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#SuperCell.add_andheisp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.SuperCell.add_andheisp" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement Anderson-Heisenberg model with classical impurity spins.
This is the anisotropic version, somewhat preferring spins pointing up
or down (along z-axis) due to an initial &#8220;wrong choice&#8221; of probability
distribution. It stays here merely for compatibility reasons.</p>
<dl class="docutils">
<dt>coup</dt>
<dd>exchange couplings J between conduction electrons and local
magnetic moments</dd>
<dt>mom</dt>
<dd>magnetic moment of each impurity</dd>
<dt>mix</dt>
<dd>impurity concentration</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tb.sc.SuperCell.add_andis">
<tt class="descname">add_andis</tt><big>(</big><em>pot=0.0</em>, <em>hop=-1.0</em>, <em>coup=1.0</em>, <em>mom=1.0</em>, <em>mix=0.1</em>, <em>shape=None</em>, <em>bcond=None</em>, <em>origin=None</em>, <em>bvects=None</em>, <em>label=None</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#SuperCell.add_andis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.SuperCell.add_andis" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement Anderson-Ising model, unpolarized version (impurity spins
can point up or down, isotropic distribution).</p>
<dl class="docutils">
<dt>coup</dt>
<dd>exchange couplings J between conduction electrons and local
magnetic moments</dd>
<dt>mom</dt>
<dd>magnetic moment of each impurity</dd>
<dt>mix</dt>
<dd>impurity concentration</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tb.sc.SuperCell.add_andisp">
<tt class="descname">add_andisp</tt><big>(</big><em>pot=0.0</em>, <em>hop=-1.0</em>, <em>coup=1.0</em>, <em>mom=1.0</em>, <em>mix=0.1</em>, <em>shape=None</em>, <em>bcond=None</em>, <em>origin=None</em>, <em>bvects=None</em>, <em>label=None</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#SuperCell.add_andisp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.SuperCell.add_andisp" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement Anderson-Ising model, polarized version (impurity spins
point all upwards).</p>
<dl class="docutils">
<dt><em>coup</em></dt>
<dd>exchange couplings J between electron and local magnetic moment</dd>
<dt><em>mom</em></dt>
<dd>magnetic moment of the impurity</dd>
<dt><em>mix</em></dt>
<dd>concentration of the impurities</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tb.sc.SuperCell.add_bccnn">
<tt class="descname">add_bccnn</tt><big>(</big><em>pot=0.0</em>, <em>hop=-1.0</em>, <em>shape=None</em>, <em>bcond=None</em>, <em>origin=None</em>, <em>bvects=None</em>, <em>label=None</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#SuperCell.add_bccnn"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.SuperCell.add_bccnn" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a 3-dimensional 1-band body-centered cubic lattice with
isotropic next-neighbor hopping <em>hop</em>.</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.SuperCell.add_diam">
<tt class="descname">add_diam</tt><big>(</big><em>pot=0.0</em>, <em>hop=-1.0</em>, <em>shape=None</em>, <em>bcond=None</em>, <em>origin=None</em>, <em>bvects=None</em>, <em>label=None</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#SuperCell.add_diam"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.SuperCell.add_diam" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a 3-dimensional 1-band diamond lattice with isotropic
next-neighbor hopping only <em>hop</em>.</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.SuperCell.add_fccnn">
<tt class="descname">add_fccnn</tt><big>(</big><em>pot=0.0</em>, <em>hop=-1.0</em>, <em>shape=None</em>, <em>bcond=None</em>, <em>origin=None</em>, <em>bvects=None</em>, <em>label=None</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#SuperCell.add_fccnn"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.SuperCell.add_fccnn" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a 3-dimensional 1-band face-centered cubic lattice with
isotropic next-neighbor hopping <em>hop</em>.</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.SuperCell.add_heis">
<tt class="descname">add_heis</tt><big>(</big><em>mix=0.0</em>, <em>mom=1.0</em>, <em>range=1.0</em>, <em>coup=1.0</em>, <em>spin=1.0</em>, <em>shell=1</em>, <em>shape=None</em>, <em>bcond=None</em>, <em>origin=None</em>, <em>bvects=None</em>, <em>label=None</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#SuperCell.add_heis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.SuperCell.add_heis" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a dilute (homogeneous) Heisenberg system. Do not allow long
hoppings by default (<em>longhops*=*False</em>), but make sure that hoppings
cause a contribution to the diagonal matrix elements
(<em>diaghops*=*True</em>).</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.SuperCell.add_honey">
<tt class="descname">add_honey</tt><big>(</big><em>pot=0.0</em>, <em>hop=-1.0</em>, <em>shape=None</em>, <em>bcond=None</em>, <em>origin=None</em>, <em>label=None</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#SuperCell.add_honey"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.SuperCell.add_honey" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a 2-dimensional 1-band honeycomb lattice with isotropic
next-neighbor hopping <em>hop</em>.</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.SuperCell.add_hop">
<tt class="descname">add_hop</tt><big>(</big><em>*ents</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#SuperCell.add_hop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.SuperCell.add_hop" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a hopping between the given entities, additionally restricted to
a certain distance <em>delta</em> that must exist between the coordinates of
the sites (within a certain tolerance) where the given entities are
located.  The hopping parameter <em>hop</em> can either be given by a constant
or be drawn from a random distribution. If it is <em>True</em>, also hopping
in the opposite direction will be allowed.</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.SuperCell.add_lat">
<tt class="descname">add_lat</tt><big>(</big><em>*lats</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#SuperCell.add_lat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.SuperCell.add_lat" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a lattice to the supercell by defining a unitcell that may
contain multiple sites and that is repeated periodically in space a
given number of times in each dimension <em>shape</em>.</p>
<p>Set the origin and the basis vectors <em>bvects</em> to control where and how
the lattice stretches within the supercell.</p>
<p>Also, predefined lattice objects may be given as positional arguments.
Then, no keyword arguments may be given.</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.SuperCell.add_scnn">
<tt class="descname">add_scnn</tt><big>(</big><em>pot=0.0</em>, <em>hop=-1.0</em>, <em>shape=None</em>, <em>bcond=None</em>, <em>origin=None</em>, <em>bvects=None</em>, <em>label=None</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#SuperCell.add_scnn"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.SuperCell.add_scnn" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a <em>dim</em>-dimensional 1-band simple cubic lattice with
isotropic next-neighbor hopping <em>hop</em>.</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.SuperCell.add_scsnn">
<tt class="descname">add_scsnn</tt><big>(</big><em>pot=0.0</em>, <em>hop1=-1.0</em>, <em>hop2=-1.0</em>, <em>shape=None</em>, <em>bcond=None</em>, <em>origin=None</em>, <em>bvects=None</em>, <em>label=None</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#SuperCell.add_scsnn"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.SuperCell.add_scsnn" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a <em>dim</em>-dimensional 1-band simple cubic lattice with
isotropic next-neighbor <em>hop1</em> and second-next-neighbor hopping
<em>hop2</em>.</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.SuperCell.add_site">
<tt class="descname">add_site</tt><big>(</big><em>*sites</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#SuperCell.add_site"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.SuperCell.add_site" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a site to the supercell at the given coordinates <em>coord</em>. For a
complete list of possible arguments, look at the definition of
<tt class="xref py py-meth docutils literal"><span class="pre">Site.__init__()</span></tt>.</p>
<p>Also, predefined site objects may be given as positional arguments.
Then, no keyword arguments may be given.</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.SuperCell.add_sparselat">
<tt class="descname">add_sparselat</tt><big>(</big><em>*lats</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#SuperCell.add_sparselat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.SuperCell.add_sparselat" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a sparse lattice to the supercell by defining a unitcell that
may contain multiple sites and that is placed on only a few of the
lattice sites within the given shape of the lattice.</p>
<p>Set the origin and the basis vectors <em>bvects</em> to control where and how
the lattice stretches within the supercell.</p>
<p>Also, predefined lattice objects may be given as positional arguments.
Then, no keyword arguments may be given.</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.SuperCell.add_spheres">
<tt class="descname">add_spheres</tt><big>(</big><em>mom=1.0</em>, <em>range=1.0</em>, <em>coup=1.0</em>, <em>spin=1.0</em>, <em>shell=1</em>, <em>sconc=None</em>, <em>iconc=None</em>, <em>iconcin=None</em>, <em>iconcout=None</em>, <em>rad=1.0</em>, <em>space=0.0</em>, <em>timeout='30s'</em>, <em>shape=None</em>, <em>bcond=None</em>, <em>origin=None</em>, <em>bvects=None</em>, <em>label=None</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#SuperCell.add_spheres"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.SuperCell.add_spheres" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a dilute Heisenberg system with spherical inhomogeneities. Do
not allow long hoppings by default (<em>longhops*=*False</em>), but make sure
that hoppings cause a contribution to the diagonal matrix elements
(<em>diaghops*=*True</em>).</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.SuperCell.add_triang">
<tt class="descname">add_triang</tt><big>(</big><em>pot=0.0</em>, <em>hop=-1.0</em>, <em>shape=None</em>, <em>bcond=None</em>, <em>origin=None</em>, <em>bvects=None</em>, <em>label=None</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#SuperCell.add_triang"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.SuperCell.add_triang" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a 2-dimensional 1-band triangular lattice with isotropic
next-neighbor hopping <em>hop</em>.</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.SuperCell.coords">
<tt class="descname">coords</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/tb/sc.html#SuperCell.coords"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.SuperCell.coords" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the coordinates of all the sites (also from all lattice
sites).</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.SuperCell.ents">
<tt class="descname">ents</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/tb/sc.html#SuperCell.ents"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.SuperCell.ents" title="Permalink to this definition">¶</a></dt>
<dd><p>Return generator of all entities of all the sites of all the
lattices and all the single sites of this supercell.</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.SuperCell.find_ent">
<tt class="descname">find_ent</tt><big>(</big><em>ent</em>, <em>coord=False</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#SuperCell.find_ent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.SuperCell.find_ent" title="Permalink to this definition">¶</a></dt>
<dd><p>Return indices (within the big matrix) that belong to the given
entity.  If <em>coords</em> is <em>True</em>, also return the absolute coordinates
(within the supercell).</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.SuperCell.get_lat">
<tt class="descname">get_lat</tt><big>(</big><em>label</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#SuperCell.get_lat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.SuperCell.get_lat" title="Permalink to this definition">¶</a></dt>
<dd><p>Get lattice by label.</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.SuperCell.is_complex">
<tt class="descname">is_complex</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/tb/sc.html#SuperCell.is_complex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.SuperCell.is_complex" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether this supercell contains any complex potentials or
hoppings.</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.SuperCell.is_hermitian">
<tt class="descname">is_hermitian</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/tb/sc.html#SuperCell.is_hermitian"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.SuperCell.is_hermitian" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the tight binding matrix is hermitian.</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.SuperCell.is_symmetric">
<tt class="descname">is_symmetric</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/tb/sc.html#SuperCell.is_symmetric"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.SuperCell.is_symmetric" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the tight binding matrix is symmetric.</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.SuperCell.nents">
<tt class="descname">nents</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/tb/sc.html#SuperCell.nents"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.SuperCell.nents" title="Permalink to this definition">¶</a></dt>
<dd><p>Return number of entities of all lattices and all sites. Equals the
rank of the tight binding matrix.</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.SuperCell.nsites">
<tt class="descname">nsites</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/tb/sc.html#SuperCell.nsites"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.SuperCell.nsites" title="Permalink to this definition">¶</a></dt>
<dd><p>Return number of sites, including single sites as well as those of
all the lattices.</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.SuperCell.size">
<tt class="descname">size</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/tb/sc.html#SuperCell.size"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.SuperCell.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Return number of unitcells of all lattices.</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.SuperCell.tbmat">
<tt class="descname">tbmat</tt><big>(</big><em>format=None</em>, <em>distinguish=False</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#SuperCell.tbmat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.SuperCell.tbmat" title="Permalink to this definition">¶</a></dt>
<dd><p>Return tight binding matrix of this supercell, convert to the
specified format (one of &#8220;dense&#8221;, &#8220;csr&#8221;, &#8220;csc&#8221;, &#8220;dok&#8221;, &#8220;coo&#8221;, &#8220;dia&#8221;,
&#8220;bsr&#8221;, or &#8220;lil&#8221;).  If <em>all</em> is <em>True</em>, recalculate the whole matrix, do
not return a cached version. If <em>random</em> is <em>True</em>, recalculate only
random matrix elements, i.e. get a new realization of disorder. If
<em>cache</em> is <em>True</em>, always return the cached version of the matrix (if
there is no cached version, raise an exception). If <em>all</em>, <em>random</em> and
<em>cache</em> are all <em>False</em>, calculate the matrix only if there is no
cached version, otherwise just return the cache.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tb.sc.LatticeObject">
<em class="property">class </em><tt class="descclassname">tb.sc.</tt><tt class="descname">LatticeObject</tt><a class="reference internal" href="_modules/tb/sc.html#LatticeObject"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.LatticeObject" title="Permalink to this definition">¶</a></dt>
<dd><p>Define shared methods and attributes of the lattice classes (so far:
<a class="reference internal" href="#tb.sc.Lattice" title="tb.sc.Lattice"><tt class="xref py py-class docutils literal"><span class="pre">Lattice</span></tt></a> and <a class="reference internal" href="#tb.sc.SparseLattice" title="tb.sc.SparseLattice"><tt class="xref py py-class docutils literal"><span class="pre">SparseLattice</span></tt></a>).</p>
<dl class="method">
<dt id="tb.sc.LatticeObject.add_neigh">
<tt class="descname">add_neigh</tt><big>(</big><em>*neighs</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#LatticeObject.add_neigh"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.LatticeObject.add_neigh" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a neighbor interaction object to the lattice that may connect
several unitcells defined by relative vectors. For a complete list of
possible arguments, look at the definition of
<tt class="xref py py-meth docutils literal"><span class="pre">Neighbor.__init__()</span></tt>.</p>
<p>Also, predefined neighbor objects may be given as positional arguments.
Then, keyword arguments must not be given.</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.LatticeObject.get_neigh">
<tt class="descname">get_neigh</tt><big>(</big><em>label</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#LatticeObject.get_neigh"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.LatticeObject.get_neigh" title="Permalink to this definition">¶</a></dt>
<dd><p>Get neighbor by label.</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.LatticeObject.is_complex">
<tt class="descname">is_complex</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/tb/sc.html#LatticeObject.is_complex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.LatticeObject.is_complex" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether this lattice has complex potentials or hoppings.</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.LatticeObject.is_hermitian">
<tt class="descname">is_hermitian</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/tb/sc.html#LatticeObject.is_hermitian"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.LatticeObject.is_hermitian" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if tight binding matrix is hermitian.</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.LatticeObject.is_symmetric">
<tt class="descname">is_symmetric</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/tb/sc.html#LatticeObject.is_symmetric"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.LatticeObject.is_symmetric" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if tight binding matrix is symmetric.</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.LatticeObject.nsites">
<tt class="descname">nsites</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/tb/sc.html#LatticeObject.nsites"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.LatticeObject.nsites" title="Permalink to this definition">¶</a></dt>
<dd><p>Return number of sites.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tb.sc.Lattice">
<em class="property">class </em><tt class="descclassname">tb.sc.</tt><tt class="descname">Lattice</tt><big>(</big><em>dim=1</em>, <em>shape=None</em>, <em>bcond=None</em>, <em>origin=None</em>, <em>bvects=None</em>, <em>label=None</em>, <em>neighs=None</em>, <em>diaghops=False</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#Lattice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.Lattice" title="Permalink to this definition">¶</a></dt>
<dd><p>Define a regular lattice, using a unitcell that may contain multiple
sites and is repeated periodically in space a given number of times in each
dimension.</p>
<dl class="method">
<dt id="tb.sc.Lattice.coords">
<tt class="descname">coords</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/tb/sc.html#Lattice.coords"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.Lattice.coords" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the coordinates of all the sites.</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.Lattice.indmat">
<tt class="descname">indmat</tt><big>(</big><em>vects</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#Lattice.indmat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.Lattice.indmat" title="Permalink to this definition">¶</a></dt>
<dd><p>Return index matrix. Format will be coordinate sparse format
(&#8220;coo&#8221;).  It will contain ones for those blocks that have to be set to
enable hopping in the direction of the given vectors <em>vects</em>, and zeros
elsewhere.</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.Lattice.ndindex2index">
<tt class="descname">ndindex2index</tt><big>(</big><em>ndindex</em>, <em>shape=None</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#Lattice.ndindex2index"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.Lattice.ndindex2index" title="Permalink to this definition">¶</a></dt>
<dd><p>Return index of the given n-dimensional index <em>ndindex</em> that it would have in
the n-dimensional index list provided by <tt class="xref py py-func docutils literal"><span class="pre">scipy.ndindex()</span></tt>. If <em>ndindex</em> is a
2D array, each row is treated as an n-dimensional index, and the result
will be a 1D array of indices.  Can also be given a list of nd-indices
(2d-array).</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.Lattice.size">
<tt class="descname">size</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/tb/sc.html#Lattice.size"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.Lattice.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Return number of unitcells.</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.Lattice.tbmat">
<tt class="descname">tbmat</tt><big>(</big><em>format=None</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#Lattice.tbmat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.Lattice.tbmat" title="Permalink to this definition">¶</a></dt>
<dd><p>Return tight binding matrix of this lattice, convert to the
specified format (one of dense, csr, csc, dok, coo, dia, bsr, or
lil).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tb.sc.UnitCell">
<em class="property">class </em><tt class="descclassname">tb.sc.</tt><tt class="descname">UnitCell</tt><big>(</big><em>dim=1</em>, <em>label=None</em>, <em>sites=None</em>, <em>hops=None</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#UnitCell"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.UnitCell" title="Permalink to this definition">¶</a></dt>
<dd><p>Define the unitcell of a lattice. May contain several sites.</p>
<dl class="method">
<dt id="tb.sc.UnitCell.add_hop">
<tt class="descname">add_hop</tt><big>(</big><em>*ents</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#UnitCell.add_hop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.UnitCell.add_hop" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a hopping between the given entities. All entities must already
exist in the list of entities of the unitcell. The hopping parameter
can either be constant or drawn from a probability distribution. The
interaction may be defined as isotropic (<em>iso*=*True</em>), meaning that
also hopping in the opposite direction will be allowed.</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.UnitCell.add_site">
<tt class="descname">add_site</tt><big>(</big><em>*sites</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#UnitCell.add_site"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.UnitCell.add_site" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a site to the unitcell at the given coordinates <em>coord</em>. The
coordinates should be given as relative values from the range [0., 1.].
For a complete list of possible arguments, see the definition of
<tt class="xref py py-meth docutils literal"><span class="pre">Site.__init__()</span></tt>.</p>
<p>Also, predefined site objects may be given as positional arguments.
Then, keyword arguments must not be given.</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.UnitCell.ents">
<tt class="descname">ents</tt><big>(</big><em>sites=False</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#UnitCell.ents"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.UnitCell.ents" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all entities of all sites that exist in this unitcell. If
<em>sites</em> is <em>True</em>, also return the site where the entity is located.</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.UnitCell.get_site">
<tt class="descname">get_site</tt><big>(</big><em>label</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#UnitCell.get_site"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.UnitCell.get_site" title="Permalink to this definition">¶</a></dt>
<dd><p>Get site by label.</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.UnitCell.is_complex">
<tt class="descname">is_complex</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/tb/sc.html#UnitCell.is_complex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.UnitCell.is_complex" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether this unitcell object contains any complex potentials
or hoppings.</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.UnitCell.nsites">
<tt class="descname">nsites</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/tb/sc.html#UnitCell.nsites"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.UnitCell.nsites" title="Permalink to this definition">¶</a></dt>
<dd><p>Return number of sites.</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.UnitCell.tbmat">
<tt class="descname">tbmat</tt><big>(</big><em>format=None</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#UnitCell.tbmat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.UnitCell.tbmat" title="Permalink to this definition">¶</a></dt>
<dd><p>Return submatrix of the unitcell, convert to the specified format
(one of dense, csr, csc, dok, coo, dia, bsr, or lil).  If <em>new</em> is
<em>True</em>, recalculate the whole matrix, including the random hopping
dictionary.  If <em>cache</em> is <em>True</em>, always return the cached version of
the matrix (if there is no cached version, raise an exception). If
<em>new</em> and <em>cache</em> are <em>False</em>, calculate the submatrix only if there is
no cached version, otherwise just return the cache.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tb.sc.Neighbor">
<em class="property">class </em><tt class="descclassname">tb.sc.</tt><tt class="descname">Neighbor</tt><big>(</big><em>dim=1</em>, <em>unitcell=None</em>, <em>label=None</em>, <em>hops=None</em>, <em>vects=None</em>, <em>isovects=None</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#Neighbor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.Neighbor" title="Permalink to this definition">¶</a></dt>
<dd><p>Define interaction between different unitcells of a lattice.</p>
<dl class="method">
<dt id="tb.sc.Neighbor.add_hop">
<tt class="descname">add_hop</tt><big>(</big><em>*ents</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#Neighbor.add_hop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.Neighbor.add_hop" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a hopping from entity 1 of the unitcell to entity 2 of each of
the specified neighbor cells (which are specified by the given relative
vectors). All entities must be defined within the unitcell of the
lattice.  The hopping parameter can either be constant or drawn from a
probability distribution. The interaction may be defined as isotropic
(<em>iso*=*True</em>), also allowing hopping from entity 2 to entity 1 (but
still in the same direction, from this unitcell to the neighbor cell).</p>
<p>If more than two entities are given in the list <em>ents</em>, all possible
<strong>combinations</strong> are added. If <em>iso</em> is <em>True</em>, even all
<strong>permutations</strong> are added.</p>
<p>Example with three entities e1, e2, e3: The possible combinations are
(e1, e2), (e1, e3), (e2, e3).  If <em>iso</em> is <em>True</em>, there will also be
the hoppings (e3, e2), (e3, e1), (e2, e1).</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.Neighbor.add_vect">
<tt class="descname">add_vect</tt><big>(</big><em>vect=None</em>, <em>iso=False</em>, <em>perm=False</em>, <em>permall=False</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#Neighbor.add_vect"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.Neighbor.add_vect" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a vector <em>vect</em> to this neighbor interaction object, leading to
a specific neighbor cell.</p>
<p>If <em>iso</em> is <em>True</em>, also the neighbor of the negative vector is set,
with the adjoint (complex conjugated and transposed) of the hopping
matrix of this neighbor.</p>
<p>If <em>perm</em> is <em>True</em>, the neighbors of all permutations of the given
vector <em>vect</em> are set with the same neighbor hopping matrix. Of course,
if both <em>iso</em> and <em>perm</em> are True, the neighbors of the negative
vectors of all permutations are set with the adjoint of the matrix.
This case is especially useful for bcc-like structures.</p>
<p>If <em>permall</em> is <em>True</em>, the blocks of all permutations of the given
vector <em>vect</em> are set with the neighbor&#8217;s hopping matrix, <strong>including
all negative values</strong>, i.e. covering all possible directions. Not the
adjoint, but the matrix itself is always used. <strong>USE THIS OPTION WITH
CAUTION!</strong> It should only be used in systems with only one site per
unitcell. Otherwise, unwanted hoppings could occur. This option
overrides the options <em>iso</em> and <em>perm</em>.</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.Neighbor.checkhops">
<tt class="descname">checkhops</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/tb/sc.html#Neighbor.checkhops"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.Neighbor.checkhops" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if all the entities of the defined hoppings really exist in
the unitcell.</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.Neighbor.ents">
<tt class="descname">ents</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/tb/sc.html#Neighbor.ents"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.Neighbor.ents" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the entities of all the sites of the unitcell.</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.Neighbor.is_complex">
<tt class="descname">is_complex</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/tb/sc.html#Neighbor.is_complex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.Neighbor.is_complex" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether this neighbor object contains any complex hoppings.</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.Neighbor.tbmat">
<tt class="descname">tbmat</tt><big>(</big><em>format=None</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#Neighbor.tbmat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.Neighbor.tbmat" title="Permalink to this definition">¶</a></dt>
<dd><p>Return submatrix of this neighbor interaction object, containing all
constant hopping parameters. Convert to the specified <em>format</em> (one of
dense, csr, csc, dok, coo, dia, bsr, or lil).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tb.sc.Site">
<em class="property">class </em><tt class="descclassname">tb.sc.</tt><tt class="descname">Site</tt><big>(</big><em>dim=1</em>, <em>coord=None</em>, <em>label=None</em>, <em>ents=None</em>, <em>hops=None</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#Site"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.Site" title="Permalink to this definition">¶</a></dt>
<dd><p>Define a site. May be part of the unitcell of a lattice, or a single
site within the supercell. May contain several entities (orbitals).</p>
<dl class="method">
<dt id="tb.sc.Site.add_ent">
<tt class="descname">add_ent</tt><big>(</big><em>*ents</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#Site.add_ent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.Site.add_ent" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an entity (an orbital) to the site. An entity is characterized
by the constant or random potential <em>pot</em>.</p>
<p>Also, predefined site objects may be given as positional arguments.
Then, keyword arguments must not be given.</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.Site.add_hop">
<tt class="descname">add_hop</tt><big>(</big><em>*ents</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#Site.add_hop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.Site.add_hop" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a hopping between the given list of entities <em>ents</em>. All
entities must already exist in the list of entities of this site. The
hopping parameter can either be constant or drawn from a probability
distribution. The interaction may be defined as isotropic
(<em>iso*=*True</em>), meaning that also hopping in the opposite direction is
allowed.</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.Site.checkhops">
<tt class="descname">checkhops</tt><big>(</big><em>unitcell=None</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#Site.checkhops"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.Site.checkhops" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if all the entities of the hoppings exist in the list of
entities. If a <em>unitcell</em> is specified, also check if all the hopping
entities exist in that unitcell.</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.Site.get_ent">
<tt class="descname">get_ent</tt><big>(</big><em>label</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#Site.get_ent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.Site.get_ent" title="Permalink to this definition">¶</a></dt>
<dd><p>Get entity by label.</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.Site.is_complex">
<tt class="descname">is_complex</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/tb/sc.html#Site.is_complex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.Site.is_complex" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether this site contains any complex potentials or
hoppings.</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.Site.tbmat">
<tt class="descname">tbmat</tt><big>(</big><em>format=None</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#Site.tbmat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.Site.tbmat" title="Permalink to this definition">¶</a></dt>
<dd><p>Return submatrix of this site, containing all constant hoppings and
potentials. Convert to the specified format (one of dense, csr, csc,
dok, coo, dia, bsr, or lil).  If <em>new</em> is <em>True</em>, recalculate the whole
matrix, including the random hopping dictionary. If <em>cache</em> is <em>True</em>,
return the cached version of the matrix (if there is no cached version,
raise an exception). If <em>new</em> and <em>cache</em> are both <em>False</em>, calculate
the submatrix only if there is no cached version, otherwise return the
cached version.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tb.sc.Entity">
<em class="property">class </em><tt class="descclassname">tb.sc.</tt><tt class="descname">Entity</tt><big>(</big><em>pot=0.0</em>, <em>label=None</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#Entity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.Entity" title="Permalink to this definition">¶</a></dt>
<dd><p>Define an entity (i.e., an orbital), characterized by the constant or
random potential <em>pot</em>.</p>
<dl class="method">
<dt id="tb.sc.Entity.is_complex">
<tt class="descname">is_complex</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/tb/sc.html#Entity.is_complex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.Entity.is_complex" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether this entity has a complex potential.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tb.sc.SparseLattice">
<em class="property">class </em><tt class="descclassname">tb.sc.</tt><tt class="descname">SparseLattice</tt><big>(</big><em>dim=1</em>, <em>shape=None</em>, <em>bcond=None</em>, <em>origin=None</em>, <em>bvects=None</em>, <em>label=None</em>, <em>neighs=None</em>, <em>positions=None</em>, <em>longhops=False</em>, <em>diaghops=False</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#SparseLattice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.SparseLattice" title="Permalink to this definition">¶</a></dt>
<dd><p>Define a sparse lattice, using a unitcell that may contain multiple
sites. In contrast to a regular lattice, the unitcell is not repeated
periodically in space, but exists only at given positions within the
lattice grid.</p>
<p>Allow &#8220;long&#8221; hoppings if <em>longhops</em> is set to <em>True</em>. &#8220;Long&#8221; hoppings are
those that circle the whole lattice in at least one dimension due to
periodic boundary conditions (dangerous, because hoppings from a site to
itself could be possible, which would alter the value of the site
potentials).</p>
<dl class="method">
<dt id="tb.sc.SparseLattice.coords">
<tt class="descname">coords</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/tb/sc.html#SparseLattice.coords"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.SparseLattice.coords" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the coordinates of all the sites.</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.SparseLattice.indmat">
<tt class="descname">indmat</tt><big>(</big><em>vects</em>, <em>positions</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#SparseLattice.indmat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.SparseLattice.indmat" title="Permalink to this definition">¶</a></dt>
<dd><p>Return index matrix. The output format will be the coordinate sparse
format (coo).  It will contain ones for those blocks that have to be
set to enable hopping in the direction of the given vector <em>vect</em>, and
zeros elsewhere (and minus one where a sign flip should occur due to
antiperiodic boundary conditions).</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.SparseLattice.ndindex2index">
<tt class="descname">ndindex2index</tt><big>(</big><em>ndindex</em>, <em>shape=None</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#SparseLattice.ndindex2index"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.SparseLattice.ndindex2index" title="Permalink to this definition">¶</a></dt>
<dd><p>Return index of the given n-dimensional index <em>ndindex</em> that it
would have in the n-dimensional index list provided by
<tt class="xref py py-func docutils literal"><span class="pre">scipy.ndindex()</span></tt>. If <em>ndindex</em> is a 2D array, each row is treated
as a n-dimensional index, and the result will be a 1D array of
indices.</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.SparseLattice.size">
<tt class="descname">size</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/tb/sc.html#SparseLattice.size"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.SparseLattice.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Return number of cells.</p>
</dd></dl>

<dl class="method">
<dt id="tb.sc.SparseLattice.tbmat">
<tt class="descname">tbmat</tt><big>(</big><em>format=None</em>, <em>distinguish=False</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#SparseLattice.tbmat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.SparseLattice.tbmat" title="Permalink to this definition">¶</a></dt>
<dd><p>Return tight binding matrix of this sparse lattice, and convert it
to the specified <em>format</em> (dense, csr, csc, dok, coo, dia, bsr, or
lil).</p>
<p>If <em>distinguish</em> is <em>True</em>, also return a tuple of index lists,
specifying how the positions can be distinguished.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="tb.sc.scnnmat">
<tt class="descclassname">tb.sc.</tt><tt class="descname">scnnmat</tt><big>(</big><em>shape</em>, <em>pot=0.0</em>, <em>hop=-1.0</em>, <em>bcond=None</em>, <em>dist=None</em>, <em>loc=0.0</em>, <em>scale=1.0</em>, <em>format=None</em><big>)</big><a class="reference internal" href="_modules/tb/sc.html#scnnmat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tb.sc.scnnmat" title="Permalink to this definition">¶</a></dt>
<dd><p>Return tight binding matrix of a 1-band simple cubic lattice with
constant isotropic next-neighbor hopping <em>hop</em> and either constant
potentials <em>pot</em> or random potentials, drawn from a probability
distribution <em>dist</em> defined by the parameters <em>loc</em>, <em>scale</em>. The boundary
conditions <em>bcond</em> can be chosen to be static (&#8220;s&#8221;), periodic (&#8220;p&#8221;) or
antiperiodic (&#8220;a&#8221;) and can be set independently for each dimension. The
length of the tuple that is specifying the system dimensions <em>shape</em> is
also defining the dimensionality of the system.</p>
<p>Because of the restriction to this special case, this function reaches an
optimum of efficiency. The matrix is returned in the sparse matrix format
<em>format</em>.</p>
</dd></dl>

</div>
<div class="section" id="indices-and-tables">
<h2>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference internal" href="genindex.html"><em>Index</em></a></li>
<li><a class="reference internal" href="py-modindex.html"><em>Module Index</em></a></li>
<li><a class="reference internal" href="search.html"><em>Search Page</em></a></li>
</ul>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">tb.sc</a><ul>
<li><a class="reference internal" href="#classes">Classes</a></li>
<li><a class="reference internal" href="#functions">Functions</a></li>
<li><a class="reference internal" href="#indices-and-tables">Indices and tables</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="misc.html"
                        title="previous chapter">tb.misc</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="sc.core.html"
                        title="next chapter">tb.sc.core</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/sc.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="sc.core.html" title="tb.sc.core"
             >next</a> |</li>
        <li class="right" >
          <a href="misc.html" title="tb.misc"
             >previous</a> |</li>
        <li><a href="index.html">tb 0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Daniel Jung.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>