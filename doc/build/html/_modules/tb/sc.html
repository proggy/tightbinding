

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>tb.sc &mdash; tb 0.1 documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="tb 0.1 documentation" href="../../index.html" />
    <link rel="up" title="tb" href="../tb.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">tb 0.1 documentation</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li>
          <li><a href="../tb.html" accesskey="U">tb</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for tb.sc</h1><div class="highlight"><pre>
<span class="c">#!/usr/bin/env python</span>
<span class="c"># -*- coding: utf-8 -*-</span>
<span class="c">#</span>
<span class="c"># Copyright notice</span>
<span class="c"># ----------------</span>
<span class="c">#</span>
<span class="c"># Copyright (C) 2013-2014 Daniel Jung</span>
<span class="c"># Contact: djungbremen@gmail.com</span>
<span class="c">#</span>
<span class="c"># This program is free software; you can redistribute it and/or modify it</span>
<span class="c"># under the terms of the GNU General Public License as published by the Free</span>
<span class="c"># Software Foundation; either version 2 of the License, or (at your option)</span>
<span class="c"># any later version.</span>
<span class="c">#</span>
<span class="c"># This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="c"># ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="c"># FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for</span>
<span class="c"># more details.</span>
<span class="c">#</span>
<span class="c"># You should have received a copy of the GNU General Public License along</span>
<span class="c"># with this prograk; if not, write to the Free Software Foundation, Inc.,</span>
<span class="c"># 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.</span>
<span class="c">#</span>
<span class="sd">&quot;&quot;&quot;Package to define tight binding supercells and calculate their tight</span>
<span class="sd">binding matrices (hamiltonians) in site-occupation basis. Start by creating an</span>
<span class="sd">instance of the SuperCell class. The methods SuperCell.add_scnn and</span>
<span class="sd">SuperCell.add_fccnn (and others) give good examples how to define lattices</span>
<span class="sd">within the supercell.</span>

<span class="sd">The submodule &quot;dist&quot; contains everything needed to generate random numbers from</span>
<span class="sd">various probability distributions, including a few predefined distributions.</span>

<span class="sd">Future visions:</span>
<span class="sd">--&gt; supercell itself may have (anti)periodic boundary conditions (until now,</span>
<span class="sd">    just lattices have boundary conditions)</span>
<span class="sd">--&gt; improve Lattice.ndindex2index (increase performance even more by using a</span>
<span class="sd">    lookup table)</span>
<span class="sd">--&gt; add special algorithms for special cases (e.g., Lattice.scnnmat)</span>
<span class="sd">--&gt; add automatic performance checks (compare times for finding the connections</span>
<span class="sd">    to the setting of matrix elements, random and constant)</span>
<span class="sd">--&gt; rename &quot;dim&quot; to &quot;ndim&quot;, be consistent with numpy.ndarray&quot;&quot;&quot;</span>
<span class="n">__created__</span> <span class="o">=</span> <span class="s">&#39;2011-08-17&#39;</span>
<span class="n">__modified__</span> <span class="o">=</span> <span class="s">&#39;2014-01-26&#39;</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">import</span> <span class="nn">string</span>
<span class="kn">import</span> <span class="nn">core</span>
<span class="kn">import</span> <span class="nn">dist</span>
<span class="kn">import</span> <span class="nn">pos</span>
<span class="kn">import</span> <span class="nn">shells</span>
<span class="kn">from</span> <span class="nn">frog</span> <span class="kn">import</span> <span class="n">Frog</span>


<div class="viewcode-block" id="SuperCellObject"><a class="viewcode-back" href="../../sc.html#tb.sc.SuperCellObject">[docs]</a><span class="k">class</span> <span class="nc">SuperCellObject</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Abstract base class for almost all other classes defined in this module.</span>
<span class="sd">    There are certain methods that are shared by all classes used to define</span>
<span class="sd">    the supercell, so to avoid redundancy, those methods are collected here in</span>
<span class="sd">    this abstract base class.&quot;&quot;&quot;</span>
    <span class="c"># 2011-11-19</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return short string representation.&quot;&quot;&quot;</span>
        <span class="c"># 2011-09-12</span>
        <span class="c"># former sc.SuperCell.__repr__ from 2011-08-20 - 2011-08-26</span>
        <span class="k">return</span> <span class="s">&#39;&lt;&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="o">+</span><span class="s">&#39;&gt;&#39;</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return detailed string representation.&quot;&quot;&quot;</span>
        <span class="c"># 2011-09-12</span>
        <span class="c"># former sc.SuperCell.__repr__ from 2011-08-20 - 2011-08-29</span>
        <span class="n">attr</span> <span class="o">=</span> <span class="s">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">=</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
                         <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">iteritems</span><span class="p">())</span>
        <span class="k">return</span> <span class="s">&#39;&lt;&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="o">+</span><span class="s">&#39;(&#39;</span><span class="o">+</span><span class="n">attr</span><span class="o">+</span><span class="s">&#39;)&gt;&#39;</span>

<div class="viewcode-block" id="SuperCellObject.infertype"><a class="viewcode-back" href="../../sc.html#tb.sc.SuperCellObject.infertype">[docs]</a>    <span class="k">def</span> <span class="nf">infertype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return data type (complex or float) that is needed due to the</span>
<span class="sd">        defined potentials and hoppings within this object. Depends on the</span>
<span class="sd">        method is_complex that has to be defined within each child class.&quot;&quot;&quot;</span>
        <span class="c"># 2011-09-12</span>
        <span class="c"># former sc.Lattice.infertype from 2011-08-25</span>
        <span class="k">return</span> <span class="nb">complex</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_complex</span><span class="p">()</span> <span class="k">else</span> <span class="nb">float</span>
</div>
    <span class="k">def</span> <span class="nf">_ucletters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return all uppercase letters of the given string.&quot;&quot;&quot;</span>
        <span class="c"># 2011-09-12 - 2012-06-19</span>
        <span class="c"># former sc.SuperCell._ucletters from 2011-08-26</span>
        <span class="n">result</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">letter</span> <span class="ow">in</span> <span class="n">string</span><span class="o">.</span><span class="n">uppercase</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="n">letter</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="SuperCellObject.ismath"><a class="viewcode-back" href="../../sc.html#tb.sc.SuperCellObject.ismath">[docs]</a>    <span class="k">def</span> <span class="nf">ismath</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if the given string is a mathematical expression (containing</span>
<span class="sd">        only mathematical operators like &#39;+&#39;, &#39;-&#39;, &#39;*&#39;, or &#39;/&#39;, and of course</span>
<span class="sd">        digits). Can be used before using &quot;eval&quot; on some string to evaluate a</span>
<span class="sd">        given expression.</span>

<span class="sd">        Note: This function does not check if the numerical expression is</span>
<span class="sd">        actually valid. It just gives a hint if the given string should be</span>
<span class="sd">        passed to eval or not.&quot;&quot;&quot;</span>
        <span class="c"># 2011-09-13 - 2011-10-12</span>
        <span class="c"># former tb.mathexpr from 2011-06-12</span>
        <span class="k">if</span> <span class="s">&#39;+&#39;</span> <span class="ow">in</span> <span class="n">string</span> <span class="ow">or</span> <span class="s">&#39;*&#39;</span> <span class="ow">in</span> <span class="n">string</span> <span class="ow">or</span> <span class="s">&#39;/&#39;</span> <span class="ow">in</span> <span class="n">string</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>

        <span class="c"># special handling of the minus sign</span>
        <span class="k">if</span> <span class="n">string</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s">&#39;-&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">string</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;-&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="s">&#39;-&#39;</span> <span class="ow">in</span> <span class="n">string</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>
</div>
<div class="viewcode-block" id="SuperCellObject.evalmath"><a class="viewcode-back" href="../../sc.html#tb.sc.SuperCellObject.evalmath">[docs]</a>    <span class="k">def</span> <span class="nf">evalmath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cast value to the given data type (dtype). If value is a string,</span>
<span class="sd">        assume that it contains a mathematical expression, and evaluate it with</span>
<span class="sd">        eval before casting it to the specified type. Functions are passed</span>
<span class="sd">        unmodified.</span>

<span class="sd">        The function could always use eval, but this is assumed to be slower</span>
<span class="sd">        for values that do not have to be evaluated.&quot;&quot;&quot;</span>
        <span class="c"># 2011-10-12 - 2011-12-14</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s">&#39;__call__&#39;</span><span class="p">):</span>
            <span class="c"># bypass function or callable class objects (defining a certain</span>
            <span class="c"># probability distribution)</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ismath</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">dtype</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">dtype</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dtype</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

</div></div>
<div class="viewcode-block" id="SuperCell"><a class="viewcode-back" href="../../sc.html#tb.sc.SuperCell">[docs]</a><span class="k">class</span> <span class="nc">SuperCell</span><span class="p">(</span><span class="n">SuperCellObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Define tight binding supercell, using an object-oriented user interface.</span>
<span class="sd">    Create multiple sites or whole lattices of sites (repeat sites within a</span>
<span class="sd">    given unitcell periodically). Each site may hold several entities</span>
<span class="sd">    (potentials).&quot;&quot;&quot;</span>
    <span class="c"># 2011-08-17 - 2012-09-04</span>
    <span class="c"># former tb.SuperCell from 2011-03-05 - 2011-08-02</span>

    <span class="c"># initialize instance counter</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">margin</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">sites</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">lats</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">hops</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">eps</span><span class="o">=.</span><span class="mi">1</span><span class="p">):</span>  <span class="c"># bcond=None</span>
        <span class="sd">&quot;&quot;&quot;Initialize supercell.&quot;&quot;&quot;</span>
        <span class="c"># 2011-08-17 - 2011-10-12</span>

        <span class="c"># number of dimensions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalmath</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;number of dimensions must be positive integer&#39;</span>

        <span class="c"># boundary conditions</span>
        <span class="c"># yet to come for the supercell itself. So far, boundary conditions are</span>
        <span class="c"># only supported for single lattices within the supercell</span>
        <span class="c">#if bcond is None:</span>
            <span class="c">#self.bcond = &#39;p&#39;*self.dim</span>
        <span class="c">#else:</span>
            <span class="c">#self.bcond = str(bcond)</span>
            <span class="c">#assert bcond != &#39;&#39;, &#39;no boundary conditions given&#39;</span>
            <span class="c">#while len(self.bcond) &lt; self.dim:</span>
                <span class="c">#self.bcond += self.bcond[-1]</span>

        <span class="c"># set label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%s%i</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ucletters</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">),</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">label</span>

        <span class="c"># set margin</span>
        <span class="k">if</span> <span class="n">margin</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">margin</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">margin</span> <span class="o">=</span> <span class="n">margin</span>

        <span class="c"># set tolerance in finding the distances between sites</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalmath</span><span class="p">(</span><span class="n">eps</span><span class="p">)</span>

        <span class="c"># data structures</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sites</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">sites</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">sites</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lats</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">lats</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">lats</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hops</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">hops</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">hops</span>

<div class="viewcode-block" id="SuperCell.ents"><a class="viewcode-back" href="../../sc.html#tb.sc.SuperCell.ents">[docs]</a>    <span class="k">def</span> <span class="nf">ents</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return generator of all entities of all the sites of all the</span>
<span class="sd">        lattices and all the single sites of this supercell.&quot;&quot;&quot;</span>
        <span class="c"># 2011-08-31</span>
        <span class="k">for</span> <span class="n">lat</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lats</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="n">lat</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">ents</span><span class="p">():</span>
                <span class="k">yield</span> <span class="n">ent</span>
        <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="n">site</span><span class="o">.</span><span class="n">ents</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">ent</span>
</div>
<div class="viewcode-block" id="SuperCell.add_site"><a class="viewcode-back" href="../../sc.html#tb.sc.SuperCell.add_site">[docs]</a>    <span class="k">def</span> <span class="nf">add_site</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">sites</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a site to the supercell at the given coordinates (coord). For a</span>
<span class="sd">        complete list of possible arguments, look at the definition of</span>
<span class="sd">        Site.__init__.</span>

<span class="sd">        Also, predefined site objects may be given as positional arguments.</span>
<span class="sd">        Then, no keyword arguments may be given.&quot;&quot;&quot;</span>
        <span class="c"># 2011-08-23 - 2012-05-01</span>

        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sites</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">site</span> <span class="o">=</span> <span class="n">Site</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">site</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">site</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s">&#39;no keyword arguments allowed if &#39;</span> <span class="o">+</span>
                               <span class="s">&#39;positional arguments are given&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">sites</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">site</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">site</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="SuperCell.add_lat"><a class="viewcode-back" href="../../sc.html#tb.sc.SuperCell.add_lat">[docs]</a>    <span class="k">def</span> <span class="nf">add_lat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">lats</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a lattice to the supercell by defining a unitcell that may</span>
<span class="sd">        contain multiple sites and that is repeated periodically in space a</span>
<span class="sd">        given number of times in each dimension (shape).</span>

<span class="sd">        Set the origin and the basis vectors (bvects) to control where and how</span>
<span class="sd">        the lattice stretches within the supercell.</span>

<span class="sd">        Also, predefined lattice objects may be given as positional arguments.</span>
<span class="sd">        Then, no keyword arguments may be given.&quot;&quot;&quot;</span>
        <span class="c"># 2011-08-17 - 2012-05-01</span>

        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lats</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">lat</span> <span class="o">=</span> <span class="n">Lattice</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">lat</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s">&#39;no keyword arguments allowed if positional &#39;</span> <span class="o">+</span>
                               <span class="s">&#39;arguments are given&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">lat</span> <span class="ow">in</span> <span class="n">lats</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">lat</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lats</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">lats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="SuperCell.add_sparselat"><a class="viewcode-back" href="../../sc.html#tb.sc.SuperCell.add_sparselat">[docs]</a>    <span class="k">def</span> <span class="nf">add_sparselat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">lats</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a sparse lattice to the supercell by defining a unitcell that</span>
<span class="sd">        may contain multiple sites and that is placed on only a few of the</span>
<span class="sd">        lattice sites within the given shape of the lattice.</span>

<span class="sd">        Set the origin and the basis vectors (bvects) to control where and how</span>
<span class="sd">        the lattice stretches within the supercell.</span>

<span class="sd">        Also, predefined lattice objects may be given as positional arguments.</span>
<span class="sd">        Then, no keyword arguments may be given.&quot;&quot;&quot;</span>
        <span class="c"># 2012-05-01</span>
        <span class="c"># based on tb.sc.add_lat from 2011-08-17 - 2012-05-01</span>

        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lats</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">lat</span> <span class="o">=</span> <span class="n">SparseLattice</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">lat</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s">&#39;no keyword arguments allowed if positional &#39;</span> <span class="o">+</span>
                               <span class="s">&#39;arguments are given&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">lat</span> <span class="ow">in</span> <span class="n">lats</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">lat</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lats</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">lats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="SuperCell.add_hop"><a class="viewcode-back" href="../../sc.html#tb.sc.SuperCell.add_hop">[docs]</a>    <span class="k">def</span> <span class="nf">add_hop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">ents</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a hopping between the given entities, additionally restricted to</span>
<span class="sd">        a certain distance (delta) that must exist between the coordinates of</span>
<span class="sd">        the sites (within a certain tolerance) where the given entities are</span>
<span class="sd">        located.  The hopping parameter (hop) can either be given by a constant</span>
<span class="sd">        or be drawn from a random distribution. If iso is True, also hopping in</span>
<span class="sd">        the opposite direction will be allowed.&quot;&quot;&quot;</span>
        <span class="c"># 2011-08-31 - 2012-04-05</span>

        <span class="c"># make sure all entities exist at this site</span>
        <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="n">ents</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">ent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ents</span><span class="p">(),</span> \
                <span class="s">&#39;Entity </span><span class="si">%s</span><span class="s"> does not exist at this site&#39;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="n">ent</span><span class="p">)</span>

        <span class="c"># handle multiple entities</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ents</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;at least two entities have to be given&#39;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ents</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ent1</span><span class="p">,</span> <span class="n">ent2</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">ents</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">ent1</span><span class="p">,</span> <span class="n">ent2</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ent1</span><span class="p">,</span> <span class="n">ent2</span> <span class="o">=</span> <span class="n">ents</span>

            <span class="c"># get keyword arguments</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;delta&#39;</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span>
            <span class="n">hop</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;hop&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">)</span>
            <span class="n">iso</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;iso&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>

            <span class="c"># check if the two entities are identical</span>
            <span class="k">if</span> <span class="n">ent1</span> <span class="o">==</span> <span class="n">ent2</span> <span class="ow">and</span> <span class="n">delta</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
                <span class="c"># then just redefine the potential of that entity</span>
                <span class="n">ent1</span><span class="o">.</span><span class="n">pot</span> <span class="o">=</span> <span class="n">hop</span>
                <span class="k">return</span>

            <span class="c"># constant or random?</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">hop</span><span class="p">,</span> <span class="s">&#39;__call__&#39;</span><span class="p">):</span>
                <span class="c"># random hopping</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">hops</span><span class="p">[</span><span class="n">ent1</span><span class="p">,</span> <span class="n">ent2</span><span class="p">,</span> <span class="n">delta</span><span class="p">]</span> <span class="o">=</span> <span class="n">hop</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># constant hopping</span>
                <span class="k">if</span> <span class="n">hop</span> <span class="o">==</span> <span class="mf">0.</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ent1</span><span class="p">,</span> <span class="n">ent2</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hops</span><span class="p">:</span>
                    <span class="k">del</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hops</span><span class="p">[</span><span class="n">ent1</span><span class="p">,</span> <span class="n">ent2</span><span class="p">,</span> <span class="n">delta</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">hops</span><span class="p">[</span><span class="n">ent1</span><span class="p">,</span> <span class="n">ent2</span><span class="p">,</span> <span class="n">delta</span><span class="p">]</span> <span class="o">=</span> <span class="n">hop</span>

            <span class="c"># isotropic hopping?</span>
            <span class="k">if</span> <span class="n">iso</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">ent2</span><span class="p">,</span> <span class="n">ent1</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="n">delta</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(),</span>
                             <span class="n">iso</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                <span class="c">### What happens if hop is random and iso is True?</span>
</div>
<div class="viewcode-block" id="SuperCell.tbmat"><a class="viewcode-back" href="../../sc.html#tb.sc.SuperCell.tbmat">[docs]</a>    <span class="k">def</span> <span class="nf">tbmat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">distinguish</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return tight binding matrix of this supercell, convert to the</span>
<span class="sd">        specified format (one of dense, csr, csc, dok, coo, dia, bsr, or lil).</span>
<span class="sd">        If all is True, recalculate the whole matrix, do not return a cached</span>
<span class="sd">        version. If random is True, recalculate only random matrix elements,</span>
<span class="sd">        i.e.  get a new realization of disorder. If cache is True, always</span>
<span class="sd">        return the cached version of the matrix (if there is no cached version,</span>
<span class="sd">        raise an exception). If all, random and cache are all False, calculate</span>
<span class="sd">        the matrix only if there is no cached version, otherwise just return</span>
<span class="sd">        the cache.&quot;&quot;&quot;</span>
        <span class="c"># 2011-09-01 - 2012-09-04</span>

        <span class="c"># first, fill all blocks on the main diagonal, containing all</span>
        <span class="c"># potentials and intra-lattice and intra-site hoppings</span>
        <span class="c">#print time.ctime(), \</span>
        <span class="c">#&#39;create matrix of supercell and set diagonal blocks...&#39;</span>
        <span class="n">stateclasses</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">nblocks</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lats</span><span class="p">)</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">)</span>  <span class="c"># number of blocks</span>
        <span class="n">blocks</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="n">nblocks</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nblocks</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">obj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lats</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">SparseLattice</span><span class="p">):</span>
                <span class="c"># only SparseLattice.tbmat knows the keyword &quot;distinguish&quot;</span>
                <span class="n">blocks</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">ind</span><span class="p">],</span> <span class="n">stateclasses</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">tbmat</span><span class="p">(</span><span class="n">distinguish</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">blocks</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">tbmat</span><span class="p">()</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">bmat</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">infertype</span><span class="p">())</span><span class="o">.</span><span class="n">todok</span><span class="p">()</span>
        <span class="c">#print time.ctime(), &#39;matrix of supercell created, diagonal blocks set&#39;</span>

        <span class="c"># add hoppings, cycle all hopping definitions</span>
        <span class="c">#print time.ctime(), &#39;add supercell hoppings...&#39;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">ent1</span><span class="p">,</span> <span class="n">ent2</span><span class="p">,</span> <span class="n">delta</span><span class="p">),</span> <span class="n">hop</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hops</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="c"># get all indices and coordinates of the two entities</span>
            <span class="n">einds1</span><span class="p">,</span> <span class="n">coords1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_ent</span><span class="p">(</span><span class="n">ent1</span><span class="p">,</span> <span class="n">coord</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">einds2</span><span class="p">,</span> <span class="n">coords2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_ent</span><span class="p">(</span><span class="n">ent2</span><span class="p">,</span> <span class="n">coord</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="c">### change find_ent, improve performance even more</span>

            <span class="c"># instanciate kd-trees</span>
            <span class="n">tree1</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">KDTree</span><span class="p">(</span><span class="n">coords1</span><span class="p">)</span>
            <span class="n">tree2</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">KDTree</span><span class="p">(</span><span class="n">coords2</span><span class="p">)</span>

            <span class="c"># calculate distance matrix (sparse, dictionary-of-keys format)</span>
            <span class="n">dismat</span> <span class="o">=</span> <span class="n">tree1</span><span class="o">.</span><span class="n">sparse_distance_matrix</span><span class="p">(</span><span class="n">tree2</span><span class="p">,</span>
                                                  <span class="n">max_distance</span><span class="o">=</span><span class="n">delta</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span>

            <span class="c"># filter distances, find those that are greater than delta-eps</span>
            <span class="n">inds</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dismat</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">&gt;</span>
                                     <span class="n">delta</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">inds1</span><span class="p">,</span> <span class="n">inds2</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dismat</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="n">inds</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>

            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">hop</span><span class="p">,</span> <span class="s">&#39;__call__&#39;</span><span class="p">):</span>
                <span class="c"># generate random variates</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">hop</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">inds1</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inds1</span><span class="p">))</span><span class="o">*</span><span class="n">hop</span>

            <span class="c"># add this hopping to the big matrix</span>
            <span class="n">helper</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">data</span><span class="p">,</span>
                                              <span class="p">(</span><span class="n">einds1</span><span class="p">[</span><span class="n">inds1</span><span class="p">],</span> <span class="n">einds2</span><span class="p">[</span><span class="n">inds2</span><span class="p">])),</span>
                                             <span class="n">shape</span><span class="o">=</span><span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">mat</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">helper</span><span class="o">.</span><span class="n">todok</span><span class="p">())</span>

            <span class="c"># another, presumably slower approach, using nested Python</span>
            <span class="c"># for-loops select entities, together with their coordinates and</span>
            <span class="c"># indices</span>
            <span class="c">#for inds1, coords1 in self.loop_ent(ent1, coord=True):</span>
                <span class="c">#for inds2, coords2 in self.loop_ent(ent2, coord=True):</span>
                    <span class="c">#dist2 = sum((coords1-coords2)**2)</span>
                    <span class="c">#if dist2 &gt;= delta-tol/2 and dist &lt;= delta+tol/2:</span>
                    <span class="c">### better: allclose</span>
        <span class="c">#print time.ctime(), &#39;supercell hoppings added&#39;</span>

        <span class="c"># return the matrix</span>
        <span class="k">if</span> <span class="n">distinguish</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">stateclasses</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">stateclasses</span> <span class="o">=</span> <span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),)</span>
            <span class="k">return</span> <span class="n">mat</span><span class="o">.</span><span class="n">asformat</span><span class="p">(</span><span class="n">format</span><span class="p">),</span> <span class="n">stateclasses</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mat</span><span class="o">.</span><span class="n">asformat</span><span class="p">(</span><span class="n">format</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="SuperCell.is_symmetric"><a class="viewcode-back" href="../../sc.html#tb.sc.SuperCell.is_symmetric">[docs]</a>    <span class="k">def</span> <span class="nf">is_symmetric</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if tight binding matrix is symmetric.&quot;&quot;&quot;</span>
        <span class="c"># 2012-02-02</span>
        <span class="c"># Convert the matrix to the dok-format before comparison</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tbmat</span><span class="p">()</span>  <span class="c"># cache=True</span>
        <span class="k">return</span> <span class="n">mat</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">todok</span><span class="p">()</span> <span class="o">==</span> <span class="n">mat</span><span class="o">.</span><span class="n">todok</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="SuperCell.is_hermitian"><a class="viewcode-back" href="../../sc.html#tb.sc.SuperCell.is_hermitian">[docs]</a>    <span class="k">def</span> <span class="nf">is_hermitian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if tight binding matrix is hermitian.&quot;&quot;&quot;</span>
        <span class="c"># 2012-02-02</span>
        <span class="c"># Convert the matrix to the dok-format before comparison</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tbmat</span><span class="p">()</span>  <span class="c"># cache=True</span>
        <span class="k">return</span> <span class="n">mat</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">todok</span><span class="p">()</span> <span class="o">==</span> <span class="n">mat</span><span class="o">.</span><span class="n">todok</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="SuperCell.find_ent"><a class="viewcode-back" href="../../sc.html#tb.sc.SuperCell.find_ent">[docs]</a>    <span class="k">def</span> <span class="nf">find_ent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ent</span><span class="p">,</span> <span class="n">coord</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return indices (within the big matrix) that belong to the given</span>
<span class="sd">        entity.  If coords is True, also return the absolute coordinates</span>
<span class="sd">        (within the supercell).&quot;&quot;&quot;</span>
        <span class="c"># 2011-09-02 - 2011-09-05</span>

        <span class="c"># initialize offset for matrix index</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c"># initialize data collectors</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c"># search lattices</span>
        <span class="k">for</span> <span class="n">lat</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lats</span><span class="p">:</span>
            <span class="c"># get number of entities specified within the unitcell of the</span>
            <span class="c"># lattice</span>
            <span class="n">enum</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">lat</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">ents</span><span class="p">()))</span>

            <span class="k">for</span> <span class="n">eind</span><span class="p">,</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">site</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lat</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">ents</span><span class="p">(</span><span class="n">sites</span><span class="o">=</span><span class="bp">True</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">e</span> <span class="o">==</span> <span class="n">ent</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">ucind</span><span class="p">,</span> <span class="n">uccoord</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">lat</span><span class="o">.</span><span class="n">shape</span><span class="p">)):</span>
                        <span class="n">inds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">offset</span><span class="o">+</span><span class="n">ucind</span><span class="o">*</span><span class="n">enum</span><span class="o">+</span><span class="n">eind</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">coord</span><span class="p">:</span>
                            <span class="n">origin</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lat</span><span class="o">.</span><span class="n">origin</span><span class="p">)</span>
                            <span class="n">bvects</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lat</span><span class="o">.</span><span class="n">bvects</span><span class="p">)</span>
                            <span class="n">uccoord</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">uccoord</span><span class="p">)</span>
                            <span class="n">sitecoord</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">coord</span><span class="p">)</span>
                            <span class="n">coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">origin</span><span class="o">+</span><span class="n">scipy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">bvects</span><span class="p">,</span>
                                                                 <span class="n">uccoord</span> <span class="o">+</span>
                                                                 <span class="n">sitecoord</span><span class="p">)))</span>
                            <span class="c">#yield offset+ucind*enum+eind, \</span>
                                    <span class="c">#origin+scipy.dot(bvects, uccoord+coord)</span>
                        <span class="c">#else:</span>
                            <span class="c">#yield offset+ucind*enum+eind</span>

                    <span class="c"># double entries would not make any sense</span>
                    <span class="k">break</span>

            <span class="c"># increase offset</span>
            <span class="n">offset</span> <span class="o">+=</span> <span class="n">enum</span><span class="o">*</span><span class="n">lat</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>

        <span class="c"># search single sites</span>
        <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">:</span>
            <span class="c"># Get number of entities specified on the site</span>
            <span class="n">enum</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">ents</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">eind</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">ents</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">e</span> <span class="o">==</span> <span class="n">ent</span><span class="p">:</span>
                    <span class="n">inds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">offset</span><span class="o">+</span><span class="n">eind</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">coord</span><span class="p">:</span>
                        <span class="n">coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">coord</span><span class="p">)</span>
                        <span class="c">#yield offset+eind, scipy.array(site.coord)</span>
                    <span class="c">#else:</span>
                        <span class="c">#yield offset+eind</span>

                    <span class="c"># Double entries would not make any sense</span>
                    <span class="k">break</span>

            <span class="c"># increase offset</span>
            <span class="n">offset</span> <span class="o">+=</span> <span class="n">enum</span>

        <span class="c"># return results</span>
        <span class="k">if</span> <span class="n">coord</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">inds</span><span class="p">),</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">inds</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="SuperCell.add_scnn"><a class="viewcode-back" href="../../sc.html#tb.sc.SuperCell.add_scnn">[docs]</a>    <span class="k">def</span> <span class="nf">add_scnn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pot</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">hop</span><span class="o">=-</span><span class="mf">1.</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">bcond</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">bvects</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a dim-dimensional 1-band simple cubic lattice with isotropic</span>
<span class="sd">        next-neighbor hopping (hop) only.&quot;&quot;&quot;</span>
        <span class="c"># 2011-08-28 - 2011-11-09</span>
        <span class="c"># former tb.SuperCell.add_scnn</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_lat</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">bcond</span><span class="o">=</span><span class="n">bcond</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">,</span>
                           <span class="n">bvects</span><span class="o">=</span><span class="n">bvects</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
        <span class="n">site</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">add_site</span><span class="p">()</span>
        <span class="n">ent</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">add_ent</span><span class="p">(</span><span class="n">pot</span><span class="o">=</span><span class="n">pot</span><span class="p">)</span>
        <span class="n">nei</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">add_neigh</span><span class="p">()</span>
        <span class="n">nei</span><span class="o">.</span><span class="n">add_vect</span><span class="p">(</span><span class="n">permall</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">nei</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">ent</span><span class="p">,</span> <span class="n">ent</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lat</span>
</div>
<div class="viewcode-block" id="SuperCell.add_triang"><a class="viewcode-back" href="../../sc.html#tb.sc.SuperCell.add_triang">[docs]</a>    <span class="k">def</span> <span class="nf">add_triang</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pot</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">hop</span><span class="o">=-</span><span class="mf">1.</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">bcond</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                   <span class="n">bvects</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a 2-dimensional 1-band triangular lattice with isotropic</span>
<span class="sd">        next-neighbor hopping (hop) only.&quot;&quot;&quot;</span>
        <span class="c"># 2011-12-11</span>
        <span class="c">### bvects should be chosen to get lattice with equilateral triangles</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_lat</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">bcond</span><span class="o">=</span><span class="n">bcond</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">,</span>
                           <span class="n">bvects</span><span class="o">=</span><span class="n">bvects</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
        <span class="n">site</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">add_site</span><span class="p">()</span>
        <span class="n">ent</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">add_ent</span><span class="p">(</span><span class="n">pot</span><span class="o">=</span><span class="n">pot</span><span class="p">)</span>
        <span class="n">nei</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">add_neigh</span><span class="p">()</span>
        <span class="n">nei</span><span class="o">.</span><span class="n">add_vect</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">permall</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">nei</span><span class="o">.</span><span class="n">add_vect</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">nei</span><span class="o">.</span><span class="n">add_vect</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">nei</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">ent</span><span class="p">,</span> <span class="n">ent</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lat</span>
</div>
<div class="viewcode-block" id="SuperCell.add_fccnn"><a class="viewcode-back" href="../../sc.html#tb.sc.SuperCell.add_fccnn">[docs]</a>    <span class="k">def</span> <span class="nf">add_fccnn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pot</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">hop</span><span class="o">=-</span><span class="mf">1.</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">bcond</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                  <span class="n">bvects</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>  <span class="c"># pdist=None, hdist=None,</span>
                                             <span class="c"># ploc=0., pscale=1., hloc=-1.,</span>
                                             <span class="c"># hscale=1.</span>
        <span class="sd">&quot;&quot;&quot;Create a 3-dimensional 1-band face-centered cubic lattice with</span>
<span class="sd">        isotropic next-neighbor hopping (hop) only.&quot;&quot;&quot;</span>
        <span class="c"># 2011-08-28 - 2011-11-09</span>
        <span class="c"># former tb.SuperCell.add_fccnn</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="s">&#39;a fcc lattice can only be created in a &#39;</span> <span class="o">+</span> \
                              <span class="s">&#39;3-dimensional supercell&#39;</span>

        <span class="c"># create lattice</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_lat</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">bcond</span><span class="o">=</span><span class="n">bcond</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">,</span>
                           <span class="n">bvects</span><span class="o">=</span><span class="n">bvects</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>

        <span class="c"># add the four sites that exist in the conventional unitcell of a fcc</span>
        <span class="c"># lattice</span>
        <span class="n">siteA</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">add_site</span><span class="p">(</span><span class="n">coord</span><span class="o">=</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;Site A&#39;</span><span class="p">)</span>
        <span class="n">siteB</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">add_site</span><span class="p">(</span><span class="n">coord</span><span class="o">=</span><span class="p">(</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="mf">0.</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;Site B&#39;</span><span class="p">)</span>
        <span class="n">siteC</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">add_site</span><span class="p">(</span><span class="n">coord</span><span class="o">=</span><span class="p">(</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">.</span><span class="mi">5</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;Site C&#39;</span><span class="p">)</span>
        <span class="n">siteD</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">add_site</span><span class="p">(</span><span class="n">coord</span><span class="o">=</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="o">.</span><span class="mi">5</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;Site D&#39;</span><span class="p">)</span>

        <span class="c"># add a potential to each of the sites</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">siteA</span><span class="o">.</span><span class="n">add_ent</span><span class="p">(</span><span class="n">pot</span><span class="o">=</span><span class="n">pot</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;A&#39;</span><span class="p">)</span>  <span class="c"># dist=pdist, loc=ploc,</span>
                                               <span class="c"># scale=pscale</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">siteB</span><span class="o">.</span><span class="n">add_ent</span><span class="p">(</span><span class="n">pot</span><span class="o">=</span><span class="n">pot</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;B&#39;</span><span class="p">)</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">siteC</span><span class="o">.</span><span class="n">add_ent</span><span class="p">(</span><span class="n">pot</span><span class="o">=</span><span class="n">pot</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;C&#39;</span><span class="p">)</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">siteD</span><span class="o">.</span><span class="n">add_ent</span><span class="p">(</span><span class="n">pot</span><span class="o">=</span><span class="n">pot</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;D&#39;</span><span class="p">)</span>

        <span class="c"># define intra-unitcell hoppings</span>
        <span class="n">lat</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">,</span> <span class="n">iso</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c"># dist=hdist, loc=hloc,</span>
                                                       <span class="c"># scale=hscale</span>
        <span class="n">lat</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">,</span> <span class="n">iso</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">lat</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">,</span> <span class="n">iso</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">lat</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">,</span> <span class="n">iso</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">lat</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">,</span> <span class="n">iso</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">lat</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">,</span> <span class="n">iso</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="c"># define neighbors</span>
        <span class="n">n001</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">add_neigh</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s">&#39;N001&#39;</span><span class="p">)</span>
        <span class="n">n010</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">add_neigh</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s">&#39;N010&#39;</span><span class="p">)</span>
        <span class="n">n100</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">add_neigh</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s">&#39;N100&#39;</span><span class="p">)</span>
        <span class="n">n011</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">add_neigh</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s">&#39;N011&#39;</span><span class="p">)</span>
        <span class="n">n101</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">add_neigh</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s">&#39;N101&#39;</span><span class="p">)</span>
        <span class="n">n110</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">add_neigh</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s">&#39;N110&#39;</span><span class="p">)</span>
        <span class="n">n01_1</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">add_neigh</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s">&#39;N01_1&#39;</span><span class="p">)</span>  <span class="c"># the underscore stands for minus</span>
        <span class="n">n10_1</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">add_neigh</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s">&#39;N10_1&#39;</span><span class="p">)</span>
        <span class="n">n1_10</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">add_neigh</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s">&#39;N1_10&#39;</span><span class="p">)</span>

        <span class="c"># set the vectors for each neighbor that lead to the respective</span>
        <span class="c"># neighboring unitcells</span>
        <span class="n">n001</span><span class="o">.</span><span class="n">add_vect</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">iso</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">n010</span><span class="o">.</span><span class="n">add_vect</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">iso</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">n100</span><span class="o">.</span><span class="n">add_vect</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">iso</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">n011</span><span class="o">.</span><span class="n">add_vect</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">iso</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">n101</span><span class="o">.</span><span class="n">add_vect</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">iso</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">n110</span><span class="o">.</span><span class="n">add_vect</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">iso</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">n01_1</span><span class="o">.</span><span class="n">add_vect</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">iso</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">n10_1</span><span class="o">.</span><span class="n">add_vect</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">iso</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">n1_10</span><span class="o">.</span><span class="n">add_vect</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">iso</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="c"># define neighbor hoppings between A and B</span>
        <span class="n">n010</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">)</span>  <span class="c"># dist=hdist, loc=hloc, scale=hscale</span>
        <span class="n">n100</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">)</span>
        <span class="n">n110</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">)</span>

        <span class="c"># define neighbor hoppings between A and C</span>
        <span class="n">n100</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">)</span>
        <span class="n">n001</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">)</span>
        <span class="n">n101</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">)</span>

        <span class="c"># define neighbor hoppings between A and D</span>
        <span class="n">n010</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">)</span>
        <span class="n">n001</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">)</span>
        <span class="n">n011</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">)</span>

        <span class="c"># define neighbor hoppings between B and C</span>
        <span class="n">n001</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">)</span>
        <span class="n">n010</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">)</span>
        <span class="n">n01_1</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">)</span>

        <span class="c"># define neighbor hoppings between B and D</span>
        <span class="n">n100</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">)</span>
        <span class="n">n10_1</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">)</span>
        <span class="n">n001</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">)</span>

        <span class="c"># define neighbor hoppings between C and D</span>
        <span class="n">n100</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">)</span>
        <span class="n">n1_10</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">)</span>
        <span class="n">n010</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">)</span>

        <span class="c"># return reference to this newly created lattice object</span>
        <span class="k">return</span> <span class="n">lat</span>
</div>
<div class="viewcode-block" id="SuperCell.add_bccnn"><a class="viewcode-back" href="../../sc.html#tb.sc.SuperCell.add_bccnn">[docs]</a>    <span class="k">def</span> <span class="nf">add_bccnn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pot</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">hop</span><span class="o">=-</span><span class="mf">1.</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">bcond</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                  <span class="n">bvects</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>  <span class="c"># pdist=None, ploc=0., pscale=1.,</span>
                                             <span class="c"># hdist=None, hloc=-1., hscale=1.</span>
        <span class="sd">&quot;&quot;&quot;Create a 3-dimensional 1-band body-centered cubic lattice with</span>
<span class="sd">        isotropic next-neighbor hopping (hop) only.&quot;&quot;&quot;</span>
        <span class="c"># 2011-08-28 - 2011-11-09</span>
        <span class="c"># former tb.SuperCell.add_bccnn</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="s">&#39;a bcc lattice can only be created in a &#39;</span> <span class="o">+</span> \
                              <span class="s">&#39;3-dimensional supercell&#39;</span>

        <span class="c"># create lattice</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_lat</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">bcond</span><span class="o">=</span><span class="n">bcond</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">,</span>
                           <span class="n">bvects</span><span class="o">=</span><span class="n">bvects</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>

        <span class="c"># add the two sites that exist in the conventional unitcell of a bcc</span>
        <span class="c"># lattice</span>
        <span class="n">siteA</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">add_site</span><span class="p">(</span><span class="n">coord</span><span class="o">=</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;Site A&#39;</span><span class="p">)</span>
        <span class="n">siteB</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">add_site</span><span class="p">(</span><span class="n">coord</span><span class="o">=</span><span class="p">(</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="o">.</span><span class="mi">5</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;Site B&#39;</span><span class="p">)</span>

        <span class="c"># add a potential to each of the sites</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">siteA</span><span class="o">.</span><span class="n">add_ent</span><span class="p">(</span><span class="n">pot</span><span class="o">=</span><span class="n">pot</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;A&#39;</span><span class="p">)</span>  <span class="c"># dist=pdist, loc=ploc,</span>
                                               <span class="c"># scale=pscale</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">siteB</span><span class="o">.</span><span class="n">add_ent</span><span class="p">(</span><span class="n">pot</span><span class="o">=</span><span class="n">pot</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;B&#39;</span><span class="p">)</span>

        <span class="c"># define intra-unitcell hoppings</span>
        <span class="n">lat</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">,</span> <span class="n">iso</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c"># dist=hdist, loc=hloc,</span>
                                                       <span class="c"># scale=hscale</span>

        <span class="c"># define next-neighbor hoppings</span>
        <span class="n">nei</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">add_neigh</span><span class="p">()</span>
        <span class="n">nei</span><span class="o">.</span><span class="n">add_vect</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">iso</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">perm</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">nei</span><span class="o">.</span><span class="n">add_vect</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">iso</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">perm</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">nei</span><span class="o">.</span><span class="n">add_vect</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">iso</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">nei</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">,</span> <span class="n">iso</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c"># dist=hdist, loc=hloc,</span>
                                              <span class="c"># scale=hscale</span>

        <span class="c"># return reference to this newly created lattice object</span>
        <span class="k">return</span> <span class="n">lat</span>
</div>
<div class="viewcode-block" id="SuperCell.add_scsnn"><a class="viewcode-back" href="../../sc.html#tb.sc.SuperCell.add_scsnn">[docs]</a>    <span class="k">def</span> <span class="nf">add_scsnn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pot</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">hop1</span><span class="o">=-</span><span class="mf">1.</span><span class="p">,</span> <span class="n">hop2</span><span class="o">=-</span><span class="mf">1.</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">bcond</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                  <span class="n">origin</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">bvects</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>  <span class="c"># pdist=None,</span>
                                                          <span class="c"># ploc=0., pscale=1.,</span>
                                                          <span class="c"># h1dist=None,</span>
                                                          <span class="c"># h1loc=-1.,</span>
                                                          <span class="c"># h1scale=1.,</span>
                                                          <span class="c"># h2dist=None,</span>
                                                          <span class="c"># h2loc=-1.,</span>
                                                          <span class="c"># h2scale=1.</span>
        <span class="sd">&quot;&quot;&quot;Create a dim-dimensional 1-band simple cubic lattice with isotropic</span>
<span class="sd">        next-neighbor (hop1) and second-next-neighbor hopping (hop2).&quot;&quot;&quot;</span>
        <span class="c"># 2011-08-28 - 2011-11-09</span>

        <span class="c"># create lattice</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_lat</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">bcond</span><span class="o">=</span><span class="n">bcond</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">,</span>
                           <span class="n">bvects</span><span class="o">=</span><span class="n">bvects</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>

        <span class="c"># add a site to the unitcell of the lattice</span>
        <span class="n">site</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">add_site</span><span class="p">()</span>

        <span class="c"># add a potential to the site</span>
        <span class="n">ent</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">add_ent</span><span class="p">(</span><span class="n">pot</span><span class="o">=</span><span class="n">pot</span><span class="p">)</span>  <span class="c"># dist=pdist, loc=ploc, scale=pscale</span>

        <span class="c"># define next neighbor hoppings</span>
        <span class="n">nei1</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">add_neigh</span><span class="p">()</span>
        <span class="n">nei1</span><span class="o">.</span><span class="n">add_vect</span><span class="p">(</span><span class="n">permall</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">nei1</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">ent</span><span class="p">,</span> <span class="n">ent</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop1</span><span class="p">)</span>  <span class="c"># dist=h1dist, loc=h1loc,</span>
                                          <span class="c"># scale=h1scale</span>

        <span class="c"># define second-next neighbor hoppings</span>
        <span class="n">nei2</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">add_neigh</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">nei2</span><span class="o">.</span><span class="n">add_vect</span><span class="p">((</span><span class="mi">2</span><span class="p">,),</span> <span class="n">iso</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nei2</span><span class="o">.</span><span class="n">add_vect</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="mi">0</span><span class="p">,)</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="n">permall</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">nei2</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">ent</span><span class="p">,</span> <span class="n">ent</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop2</span><span class="p">)</span>  <span class="c"># dist=h2dist, loc=h2loc,</span>
                                          <span class="c"># scale=h2scale</span>

        <span class="c"># Return reference to this newly created lattice object</span>
        <span class="k">return</span> <span class="n">lat</span>
</div>
<div class="viewcode-block" id="SuperCell.add_honey"><a class="viewcode-back" href="../../sc.html#tb.sc.SuperCell.add_honey">[docs]</a>    <span class="k">def</span> <span class="nf">add_honey</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pot</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">hop</span><span class="o">=-</span><span class="mf">1.</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">bcond</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                  <span class="n">label</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>  <span class="c"># pdist=None, ploc=0., pscale=1., hdist=None,</span>
                                <span class="c"># hloc=-1., hscale=1.</span>
        <span class="sd">&quot;&quot;&quot;Create a 2-dimensional 1-band honeycomb lattice with isotropic</span>
<span class="sd">        next-neighbor hopping (hop) only.&quot;&quot;&quot;</span>
        <span class="c"># 2011-08-28 - 2011-11-09</span>
        <span class="c"># former tb.SuperCell.add_honey</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;a honeycomb lattice can only be created in &#39;</span> <span class="o">+</span> \
                              <span class="s">&#39;a 2-dimensional supercell&#39;</span>

        <span class="c"># create lattice</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_lat</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">bcond</span><span class="o">=</span><span class="n">bcond</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">,</span>
                           <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
        <span class="n">lat</span><span class="o">.</span><span class="n">bvects</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">lat</span><span class="o">.</span><span class="n">bvects</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>

        <span class="c"># add the four sites that exist in the conventional unitcell of a</span>
        <span class="c"># honeycomb lattice</span>
        <span class="n">siteA</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">add_site</span><span class="p">(</span><span class="n">coord</span><span class="o">=</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span>    <span class="mf">0.</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;Site A&#39;</span><span class="p">)</span>
        <span class="n">siteB</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">add_site</span><span class="p">(</span><span class="n">coord</span><span class="o">=</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="mf">3.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;Site B&#39;</span><span class="p">)</span>
        <span class="n">siteC</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">add_site</span><span class="p">(</span><span class="n">coord</span><span class="o">=</span><span class="p">(</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span>    <span class="o">.</span><span class="mi">5</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;Site C&#39;</span><span class="p">)</span>
        <span class="n">siteD</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">add_site</span><span class="p">(</span><span class="n">coord</span><span class="o">=</span><span class="p">(</span><span class="mf">5.</span><span class="o">/</span><span class="mf">6.</span><span class="p">,</span> <span class="o">.</span><span class="mi">5</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;Site D&#39;</span><span class="p">)</span>

        <span class="c"># add a potential to each of the sites</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">siteA</span><span class="o">.</span><span class="n">add_ent</span><span class="p">(</span><span class="n">pot</span><span class="o">=</span><span class="n">pot</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;A&#39;</span><span class="p">)</span>  <span class="c"># dist=pdist, loc=ploc,</span>
                                               <span class="c"># scale=pscale</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">siteB</span><span class="o">.</span><span class="n">add_ent</span><span class="p">(</span><span class="n">pot</span><span class="o">=</span><span class="n">pot</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;B&#39;</span><span class="p">)</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">siteC</span><span class="o">.</span><span class="n">add_ent</span><span class="p">(</span><span class="n">pot</span><span class="o">=</span><span class="n">pot</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;C&#39;</span><span class="p">)</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">siteD</span><span class="o">.</span><span class="n">add_ent</span><span class="p">(</span><span class="n">pot</span><span class="o">=</span><span class="n">pot</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;D&#39;</span><span class="p">)</span>

        <span class="c"># define intra-unitcell hoppings</span>
        <span class="n">lat</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">,</span> <span class="n">iso</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c"># dist=hdist, loc=hloc,</span>
                                                       <span class="c"># scale=hscale</span>
        <span class="n">lat</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">,</span> <span class="n">iso</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">lat</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">,</span> <span class="n">iso</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="c"># define neighbor interactions</span>
        <span class="n">n10</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">add_neigh</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s">&#39;N10&#39;</span><span class="p">)</span>
        <span class="n">n01</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">add_neigh</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s">&#39;N01&#39;</span><span class="p">)</span>
        <span class="n">n11</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">add_neigh</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s">&#39;N11&#39;</span><span class="p">)</span>

        <span class="c"># add the vectors to the neighbor objects</span>
        <span class="n">n10</span><span class="o">.</span><span class="n">add_vect</span><span class="p">(</span><span class="n">vect</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">iso</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">n01</span><span class="o">.</span><span class="n">add_vect</span><span class="p">(</span><span class="n">vect</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">iso</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">n11</span><span class="o">.</span><span class="n">add_vect</span><span class="p">(</span><span class="n">vect</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">iso</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="c"># define hoppings to neighboring unitcells</span>
        <span class="n">n10</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">)</span>  <span class="c"># dist=hdist, loc=hloc, scale=hscale</span>
        <span class="n">n01</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">)</span>
        <span class="n">n11</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">)</span>

        <span class="c"># return reference to this newly created lattice object</span>
        <span class="k">return</span> <span class="n">lat</span>
</div>
<div class="viewcode-block" id="SuperCell.add_diam"><a class="viewcode-back" href="../../sc.html#tb.sc.SuperCell.add_diam">[docs]</a>    <span class="k">def</span> <span class="nf">add_diam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pot</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">hop</span><span class="o">=-</span><span class="mf">1.</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">bcond</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">bvects</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>  <span class="c"># pdist=None, ploc=0., pscale=1.,</span>
                                            <span class="c"># hdist=None, hloc=-1., hscale=1.</span>
        <span class="sd">&quot;&quot;&quot;Create a 3-dimensional 1-band diamond lattice with isotropic</span>
<span class="sd">        next-neighbor hopping only (hop).&quot;&quot;&quot;</span>
        <span class="c"># 2011-08-28 - 2011-11-09</span>
        <span class="c"># former tb.SuperCell.add_diam</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="s">&#39;a diamond lattice can only be created in a &#39;</span> <span class="o">+</span> \
                              <span class="s">&#39;3-dimensional supercell&#39;</span>

        <span class="c"># create lattice</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_lat</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">bcond</span><span class="o">=</span><span class="n">bcond</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">,</span>
                           <span class="n">bvects</span><span class="o">=</span><span class="n">bvects</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>

        <span class="c"># add the eight sites that exist in the conventional unitcell of a</span>
        <span class="c"># diamond lattice</span>
        <span class="n">siteA1</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">add_site</span><span class="p">(</span><span class="n">coord</span><span class="o">=</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;Site A1&#39;</span><span class="p">)</span>
        <span class="n">siteA2</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">add_site</span><span class="p">(</span><span class="n">coord</span><span class="o">=</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="o">.</span><span class="mi">5</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;Site A2&#39;</span><span class="p">)</span>
        <span class="n">siteA3</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">add_site</span><span class="p">(</span><span class="n">coord</span><span class="o">=</span><span class="p">(</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">.</span><span class="mi">5</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;Site A3&#39;</span><span class="p">)</span>
        <span class="n">siteA4</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">add_site</span><span class="p">(</span><span class="n">coord</span><span class="o">=</span><span class="p">(</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="mf">0.</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;Site A4&#39;</span><span class="p">)</span>
        <span class="n">siteB1</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">add_site</span><span class="p">(</span><span class="n">coord</span><span class="o">=</span><span class="p">(</span><span class="o">.</span><span class="mi">25</span><span class="p">,</span> <span class="o">.</span><span class="mi">25</span><span class="p">,</span> <span class="o">.</span><span class="mi">25</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;Site B1&#39;</span><span class="p">)</span>
        <span class="n">siteB2</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">add_site</span><span class="p">(</span><span class="n">coord</span><span class="o">=</span><span class="p">(</span><span class="o">.</span><span class="mi">25</span><span class="p">,</span> <span class="o">.</span><span class="mi">75</span><span class="p">,</span> <span class="o">.</span><span class="mi">75</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;Site B2&#39;</span><span class="p">)</span>
        <span class="n">siteB3</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">add_site</span><span class="p">(</span><span class="n">coord</span><span class="o">=</span><span class="p">(</span><span class="o">.</span><span class="mi">75</span><span class="p">,</span> <span class="o">.</span><span class="mi">25</span><span class="p">,</span> <span class="o">.</span><span class="mi">75</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;Site B3&#39;</span><span class="p">)</span>
        <span class="n">siteB4</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">add_site</span><span class="p">(</span><span class="n">coord</span><span class="o">=</span><span class="p">(</span><span class="o">.</span><span class="mi">75</span><span class="p">,</span> <span class="o">.</span><span class="mi">75</span><span class="p">,</span> <span class="o">.</span><span class="mi">25</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;Site B4&#39;</span><span class="p">)</span>

        <span class="c"># add a potential to each of the sites</span>
        <span class="n">A1</span> <span class="o">=</span> <span class="n">siteA1</span><span class="o">.</span><span class="n">add_ent</span><span class="p">(</span><span class="n">pot</span><span class="o">=</span><span class="n">pot</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;A1&#39;</span><span class="p">)</span>  <span class="c"># dist=pdist, loc=ploc,</span>
                                                  <span class="c"># scale=pscale</span>
        <span class="n">A2</span> <span class="o">=</span> <span class="n">siteA2</span><span class="o">.</span><span class="n">add_ent</span><span class="p">(</span><span class="n">pot</span><span class="o">=</span><span class="n">pot</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;A2&#39;</span><span class="p">)</span>
        <span class="n">A3</span> <span class="o">=</span> <span class="n">siteA3</span><span class="o">.</span><span class="n">add_ent</span><span class="p">(</span><span class="n">pot</span><span class="o">=</span><span class="n">pot</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;A3&#39;</span><span class="p">)</span>
        <span class="n">A4</span> <span class="o">=</span> <span class="n">siteA4</span><span class="o">.</span><span class="n">add_ent</span><span class="p">(</span><span class="n">pot</span><span class="o">=</span><span class="n">pot</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;A4&#39;</span><span class="p">)</span>
        <span class="n">B1</span> <span class="o">=</span> <span class="n">siteB1</span><span class="o">.</span><span class="n">add_ent</span><span class="p">(</span><span class="n">pot</span><span class="o">=</span><span class="n">pot</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;B1&#39;</span><span class="p">)</span>
        <span class="n">B2</span> <span class="o">=</span> <span class="n">siteB2</span><span class="o">.</span><span class="n">add_ent</span><span class="p">(</span><span class="n">pot</span><span class="o">=</span><span class="n">pot</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;B2&#39;</span><span class="p">)</span>
        <span class="n">B3</span> <span class="o">=</span> <span class="n">siteB3</span><span class="o">.</span><span class="n">add_ent</span><span class="p">(</span><span class="n">pot</span><span class="o">=</span><span class="n">pot</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;B3&#39;</span><span class="p">)</span>
        <span class="n">B4</span> <span class="o">=</span> <span class="n">siteB4</span><span class="o">.</span><span class="n">add_ent</span><span class="p">(</span><span class="n">pot</span><span class="o">=</span><span class="n">pot</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;B4&#39;</span><span class="p">)</span>

        <span class="c"># define neighbor interaction objects</span>
        <span class="n">n100</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">add_neigh</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s">&#39;N100&#39;</span><span class="p">)</span>
        <span class="n">n010</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">add_neigh</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s">&#39;N010&#39;</span><span class="p">)</span>
        <span class="n">n001</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">add_neigh</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s">&#39;N001&#39;</span><span class="p">)</span>
        <span class="n">n110</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">add_neigh</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s">&#39;N110&#39;</span><span class="p">)</span>
        <span class="n">n101</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">add_neigh</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s">&#39;N101&#39;</span><span class="p">)</span>
        <span class="n">n011</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">add_neigh</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s">&#39;N011&#39;</span><span class="p">)</span>

        <span class="c"># define vectors that lead to the respective neighboring unitcells</span>
        <span class="n">n100</span><span class="o">.</span><span class="n">add_vect</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">iso</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">n010</span><span class="o">.</span><span class="n">add_vect</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">iso</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">n001</span><span class="o">.</span><span class="n">add_vect</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">iso</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">n110</span><span class="o">.</span><span class="n">add_vect</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">iso</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">n101</span><span class="o">.</span><span class="n">add_vect</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">iso</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">n011</span><span class="o">.</span><span class="n">add_vect</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">iso</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="c"># define hoppings from and to A1</span>
        <span class="n">lat</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">A1</span><span class="p">,</span> <span class="n">B1</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">,</span> <span class="n">iso</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c"># dist=hdist,</span>
                                                         <span class="c"># loc=hloc,</span>
                                                         <span class="c"># scale=hscale</span>
        <span class="n">n110</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">B4</span><span class="p">,</span> <span class="n">A1</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">)</span>
        <span class="n">n101</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">B3</span><span class="p">,</span> <span class="n">A1</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">)</span>
        <span class="n">n011</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">B2</span><span class="p">,</span> <span class="n">A1</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">)</span>

        <span class="c"># define hoppings from and to A2</span>
        <span class="n">lat</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">A2</span><span class="p">,</span> <span class="n">B2</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">,</span> <span class="n">iso</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c"># dist=hdist,</span>
                                                         <span class="c"># loc=hloc,</span>
                                                         <span class="c"># scale=hscale</span>
        <span class="n">lat</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">A2</span><span class="p">,</span> <span class="n">B1</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">,</span> <span class="n">iso</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">n100</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">B4</span><span class="p">,</span> <span class="n">A2</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">)</span>
        <span class="n">n100</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">B3</span><span class="p">,</span> <span class="n">A2</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">)</span>

        <span class="c"># define hoppings from and to A3</span>
        <span class="n">lat</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">A3</span><span class="p">,</span> <span class="n">B3</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">,</span> <span class="n">iso</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c"># dist=hdist,</span>
                                                         <span class="c"># loc=hloc,</span>
                                                         <span class="c"># ascale=hscale</span>
        <span class="n">lat</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">A3</span><span class="p">,</span> <span class="n">B1</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">,</span> <span class="n">iso</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">n010</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">B4</span><span class="p">,</span> <span class="n">A3</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">)</span>
        <span class="n">n010</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">B2</span><span class="p">,</span> <span class="n">A3</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">)</span>

        <span class="c"># define hoppings from and to A4</span>
        <span class="n">lat</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">A4</span><span class="p">,</span> <span class="n">B4</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">,</span> <span class="n">iso</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c"># dist=hdist,</span>
                                                         <span class="c"># loc=hloc,</span>
                                                         <span class="c"># scale=hscale</span>
        <span class="n">lat</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">A4</span><span class="p">,</span> <span class="n">B1</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">,</span> <span class="n">iso</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">n001</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">B3</span><span class="p">,</span> <span class="n">A4</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">)</span>
        <span class="n">n001</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">B2</span><span class="p">,</span> <span class="n">A4</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">)</span>

        <span class="c"># return reference to this newly created lattice object</span>
        <span class="k">return</span> <span class="n">lat</span>
</div>
<div class="viewcode-block" id="SuperCell.add_heis"><a class="viewcode-back" href="../../sc.html#tb.sc.SuperCell.add_heis">[docs]</a>    <span class="k">def</span> <span class="nf">add_heis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mix</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">mom</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">coup</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">shell</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">shape</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">bcond</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">bvects</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a dilute (homogeneous) Heisenberg system. Do not allow long</span>
<span class="sd">        hoppings by default (longhops=False), but make sure that hoppings cause</span>
<span class="sd">        a contribution to the diagonal matrix elements (diaghops=True).&quot;&quot;&quot;</span>
        <span class="c"># 2012-03-14 - 2012-08-01</span>

        <span class="c"># create lattice</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_sparselat</span><span class="p">(</span><span class="n">positions</span><span class="o">=</span><span class="n">pos</span><span class="o">.</span><span class="n">hom</span><span class="p">(</span><span class="n">mix</span><span class="o">=</span><span class="n">mix</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">),</span>
                                 <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">longhops</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">diaghops</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">site</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">add_site</span><span class="p">()</span>
        <span class="n">ent</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">add_ent</span><span class="p">()</span>

        <span class="c"># calculate characteristic vectors of all shells</span>
        <span class="n">cvects</span> <span class="o">=</span> <span class="n">shells</span><span class="o">.</span><span class="n">cvects</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">shell</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>

        <span class="c"># define couplings</span>
        <span class="k">def</span> <span class="nf">couplings</span><span class="p">(</span><span class="n">vect</span><span class="p">,</span> <span class="n">coup</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
            <span class="n">distance</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vect</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">coup</span><span class="o">*</span><span class="n">scipy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">distance</span><span class="o">/</span><span class="nb">range</span><span class="p">)</span>

        <span class="c"># add potentials and hoppings, cycle shells</span>
        <span class="c"># create a Neighbor object for each shell</span>
        <span class="n">neighs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cvect</span> <span class="ow">in</span> <span class="n">cvects</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">neigh</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">add_neigh</span><span class="p">()</span>
            <span class="n">neigh</span><span class="o">.</span><span class="n">add_vect</span><span class="p">(</span><span class="n">cvect</span><span class="p">,</span> <span class="n">permall</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">neigh</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">ent</span><span class="p">,</span> <span class="n">ent</span><span class="p">,</span>
                          <span class="n">hop</span><span class="o">=-</span><span class="n">spin</span><span class="o">*</span><span class="n">couplings</span><span class="p">(</span><span class="n">cvect</span><span class="p">,</span> <span class="n">coup</span><span class="o">=</span><span class="n">coup</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="nb">range</span><span class="p">))</span>
            <span class="n">neighs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neigh</span><span class="p">)</span>

        <span class="c"># return reference to this newly created sparse lattice object</span>
        <span class="k">return</span> <span class="n">lat</span>
</div>
<div class="viewcode-block" id="SuperCell.add_spheres"><a class="viewcode-back" href="../../sc.html#tb.sc.SuperCell.add_spheres">[docs]</a>    <span class="k">def</span> <span class="nf">add_spheres</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mom</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">coup</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">shell</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">sconc</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">iconc</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">iconcin</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">iconcout</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                    <span class="n">rad</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">space</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="s">&#39;30s&#39;</span><span class="p">,</span>
                    <span class="n">shape</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">bcond</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">bvects</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                    <span class="n">label</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a dilute Heisenberg system with spherical inhomogeneities. Do</span>
<span class="sd">        not allow long hoppings by default (longhops=False), but make sure that</span>
<span class="sd">        hoppings cause a contribution to the diagonal matrix elements</span>
<span class="sd">        (diaghops=True).&quot;&quot;&quot;</span>
        <span class="c"># 2012-07-06 - 2012-08-01</span>

        <span class="c"># create lattice</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="n">pos</span><span class="o">.</span><span class="n">spheres</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">sconc</span><span class="o">=</span><span class="n">sconc</span><span class="p">,</span>
                                <span class="n">iconc</span><span class="o">=</span><span class="n">iconc</span><span class="p">,</span> <span class="n">space</span><span class="o">=</span><span class="n">space</span><span class="p">,</span>
                                <span class="n">iconcin</span><span class="o">=</span><span class="n">iconcin</span><span class="p">,</span> <span class="n">rad</span><span class="o">=</span><span class="n">rad</span><span class="p">,</span>
                                <span class="n">iconcout</span><span class="o">=</span><span class="n">iconcout</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">)</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_sparselat</span><span class="p">(</span><span class="n">positions</span><span class="o">=</span><span class="n">positions</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                 <span class="n">longhops</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">diaghops</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">site</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">add_site</span><span class="p">()</span>
        <span class="n">ent</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">add_ent</span><span class="p">()</span>

        <span class="c"># calculate characteristic vectors of all shells</span>
        <span class="n">cvects</span> <span class="o">=</span> <span class="n">shells</span><span class="o">.</span><span class="n">cvects</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">shell</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>

        <span class="c"># define couplings</span>
        <span class="k">def</span> <span class="nf">couplings</span><span class="p">(</span><span class="n">vect</span><span class="p">,</span> <span class="n">coup</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
            <span class="n">distance</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vect</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">coup</span><span class="o">*</span><span class="n">scipy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">distance</span><span class="o">/</span><span class="nb">range</span><span class="p">)</span>

        <span class="c"># add potentials and hoppings, cycle shells</span>
        <span class="c"># create a Neighbor object for each shell</span>
        <span class="n">neighs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cvect</span> <span class="ow">in</span> <span class="n">cvects</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">neigh</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">add_neigh</span><span class="p">()</span>
            <span class="n">neigh</span><span class="o">.</span><span class="n">add_vect</span><span class="p">(</span><span class="n">cvect</span><span class="p">,</span> <span class="n">permall</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">neigh</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">ent</span><span class="p">,</span> <span class="n">ent</span><span class="p">,</span>
                          <span class="n">hop</span><span class="o">=-</span><span class="n">spin</span><span class="o">*</span><span class="n">couplings</span><span class="p">(</span><span class="n">cvect</span><span class="p">,</span> <span class="n">coup</span><span class="o">=</span><span class="n">coup</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="nb">range</span><span class="p">))</span>
            <span class="n">neighs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neigh</span><span class="p">)</span>

        <span class="c"># return reference to this newly created sparse lattice object</span>
        <span class="k">return</span> <span class="n">lat</span>
</div>
<div class="viewcode-block" id="SuperCell.add_andisp"><a class="viewcode-back" href="../../sc.html#tb.sc.SuperCell.add_andisp">[docs]</a>    <span class="k">def</span> <span class="nf">add_andisp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pot</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">hop</span><span class="o">=-</span><span class="mf">1.</span><span class="p">,</span> <span class="n">coup</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">mom</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">mix</span><span class="o">=.</span><span class="mi">1</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                   <span class="n">bcond</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">bvects</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implement Anderson-Ising model, polarized version (impurity spins</span>
<span class="sd">        always point up).</span>

<span class="sd">        coup: exchange couplings J between electron and local magnetic moment</span>
<span class="sd">        mom:  magnetic moment of the impurity</span>
<span class="sd">        mix:  concentration of the impurities&quot;&quot;&quot;</span>
        <span class="c"># 2012-06-18 - 2012-06-19</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_lat</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">bcond</span><span class="o">=</span><span class="n">bcond</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">,</span>
                           <span class="n">bvects</span><span class="o">=</span><span class="n">bvects</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
        <span class="n">site</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">add_site</span><span class="p">()</span>

        <span class="c"># make sure that in case of a probability distribution, each random</span>
        <span class="c"># number is used twice (put the same random values on spin-up and</span>
        <span class="c"># spin-down sector)</span>
        <span class="c">### only works with box distribution so far</span>

        <span class="c"># evaluate mathematical expressions</span>
        <span class="n">coup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalmath</span><span class="p">(</span><span class="n">coup</span><span class="p">)</span>
        <span class="n">mix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalmath</span><span class="p">(</span><span class="n">mix</span><span class="p">)</span>
        <span class="n">mom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalmath</span><span class="p">(</span><span class="n">mom</span><span class="p">)</span>

        <span class="c"># create binary distribution for the impurities</span>
        <span class="n">binary</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">binary</span><span class="p">(</span><span class="n">mix</span><span class="o">=</span><span class="n">mix</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">coup</span><span class="o">*</span><span class="n">mom</span><span class="p">,</span> <span class="n">copies</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">pot</span><span class="p">,</span> <span class="s">&#39;__call__&#39;</span><span class="p">):</span>  <span class="c"># if isinstance(pot, dist.Distribution)</span>
            <span class="n">pot</span><span class="o">.</span><span class="n">copies</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">up</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">add_ent</span><span class="p">(</span><span class="n">pot</span><span class="o">=-</span><span class="n">binary</span><span class="o">+</span><span class="n">pot</span><span class="p">)</span>  <span class="c"># V_i+J_i*S</span>
        <span class="n">down</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">add_ent</span><span class="p">(</span><span class="n">pot</span><span class="o">=</span><span class="n">binary</span><span class="o">+</span><span class="n">pot</span><span class="p">)</span>  <span class="c"># V_i-J_i*S</span>

        <span class="c"># define next-neighbor interaction</span>
        <span class="n">nei</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">add_neigh</span><span class="p">()</span>
        <span class="n">nei</span><span class="o">.</span><span class="n">add_vect</span><span class="p">(</span><span class="n">permall</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">nei</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">up</span><span class="p">,</span> <span class="n">up</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">)</span>
        <span class="n">nei</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">down</span><span class="p">,</span> <span class="n">down</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">)</span>

        <span class="c"># return reference to the lattice object</span>
        <span class="k">return</span> <span class="n">lat</span>
</div>
<div class="viewcode-block" id="SuperCell.add_andis"><a class="viewcode-back" href="../../sc.html#tb.sc.SuperCell.add_andis">[docs]</a>    <span class="k">def</span> <span class="nf">add_andis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pot</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">hop</span><span class="o">=-</span><span class="mf">1.</span><span class="p">,</span> <span class="n">coup</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">mom</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">mix</span><span class="o">=.</span><span class="mi">1</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                  <span class="n">bcond</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">bvects</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implement Anderson-Ising model, unpolarized version (impurity spins</span>
<span class="sd">        can point up or down, isotropic distribution).</span>

<span class="sd">        coup: exchange couplings J between conduction electrons and local</span>
<span class="sd">              magnetic moments</span>
<span class="sd">        mom:  magnetic moment of each impurity</span>
<span class="sd">        mix:  impurity concentration&quot;&quot;&quot;</span>
        <span class="c"># 2013-06-27 - 2013-06-27</span>
        <span class="c"># based on tb.sc.SuperCell.add_andis (2012-06-18 - 2012-06-19)</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_lat</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">bcond</span><span class="o">=</span><span class="n">bcond</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">,</span>
                           <span class="n">bvects</span><span class="o">=</span><span class="n">bvects</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
        <span class="n">site</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">add_site</span><span class="p">()</span>

        <span class="c"># make sure that in case of a probability distribution, each random</span>
        <span class="c"># number is used twice (put the same random values on spin-up and</span>
        <span class="c"># spin-down sector)</span>
        <span class="c">### only works with box distribution so far</span>

        <span class="c"># evaluate mathematical expressions</span>
        <span class="n">coup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalmath</span><span class="p">(</span><span class="n">coup</span><span class="p">)</span>
        <span class="n">mix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalmath</span><span class="p">(</span><span class="n">mix</span><span class="p">)</span>
        <span class="n">mom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalmath</span><span class="p">(</span><span class="n">mom</span><span class="p">)</span>

        <span class="c"># create binary distribution for the impurities</span>
        <span class="n">binary</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">binary</span><span class="p">(</span><span class="n">mix</span><span class="o">=</span><span class="n">mix</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">coup</span><span class="o">*</span><span class="n">mom</span><span class="p">,</span> <span class="n">copies</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">costheta</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">binary</span><span class="p">(</span><span class="n">mix</span><span class="o">=.</span><span class="mi">5</span><span class="p">,</span> <span class="n">a</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">copies</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">pot</span><span class="p">,</span> <span class="s">&#39;__call__&#39;</span><span class="p">):</span>  <span class="c"># if isinstance(pot, dist.Distribution)</span>
            <span class="n">pot</span><span class="o">.</span><span class="n">copies</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">up</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">add_ent</span><span class="p">(</span><span class="n">pot</span><span class="o">=-</span><span class="n">binary</span><span class="o">*</span><span class="n">costheta</span><span class="o">+</span><span class="n">pot</span><span class="p">)</span>  <span class="c"># V_i+J_i*S*cos(theta)</span>
        <span class="n">down</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">add_ent</span><span class="p">(</span><span class="n">pot</span><span class="o">=</span><span class="n">binary</span><span class="o">*</span><span class="n">costheta</span><span class="o">+</span><span class="n">pot</span><span class="p">)</span>  <span class="c"># V_i-J_i*S*cos(theta)</span>

        <span class="c"># define next-neighbor interaction</span>
        <span class="n">nei</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">add_neigh</span><span class="p">()</span>
        <span class="n">nei</span><span class="o">.</span><span class="n">add_vect</span><span class="p">(</span><span class="n">permall</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">nei</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">up</span><span class="p">,</span> <span class="n">up</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">)</span>
        <span class="n">nei</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">down</span><span class="p">,</span> <span class="n">down</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">)</span>

        <span class="c"># return reference to the lattice object</span>
        <span class="k">return</span> <span class="n">lat</span>
</div>
<div class="viewcode-block" id="SuperCell.add_andheisp"><a class="viewcode-back" href="../../sc.html#tb.sc.SuperCell.add_andheisp">[docs]</a>    <span class="k">def</span> <span class="nf">add_andheisp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pot</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">hop</span><span class="o">=-</span><span class="mf">1.</span><span class="p">,</span> <span class="n">coup</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">mom</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">mix</span><span class="o">=.</span><span class="mi">1</span><span class="p">,</span>
                     <span class="n">shape</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">bcond</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">bvects</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                     <span class="n">label</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implement Anderson-Heisenberg model with classical impurity spins.</span>
<span class="sd">        This is the anisotropic version, somewhat preferring spins pointing up</span>
<span class="sd">        or down (along z-axis) due to a &quot;wrong choice&quot; of probability</span>
<span class="sd">        distribution.</span>

<span class="sd">        coup: exchange couplings J between conduction electrons and local</span>
<span class="sd">              magnetic moments</span>
<span class="sd">        mom:  magnetic moment of each impurity</span>
<span class="sd">        mix:  impurity concentration&quot;&quot;&quot;</span>
        <span class="c"># 2012-08-04 - 2012-08-21</span>

        <span class="c"># create lattice</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_lat</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">bcond</span><span class="o">=</span><span class="n">bcond</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">,</span>
                           <span class="n">bvects</span><span class="o">=</span><span class="n">bvects</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>  <span class="c"># diaghops=True</span>
        <span class="n">site</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">add_site</span><span class="p">()</span>

        <span class="c"># evaluate mathematical expressions</span>
        <span class="n">coup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalmath</span><span class="p">(</span><span class="n">coup</span><span class="p">)</span>
        <span class="n">mix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalmath</span><span class="p">(</span><span class="n">mix</span><span class="p">)</span>
        <span class="n">mom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalmath</span><span class="p">(</span><span class="n">mom</span><span class="p">)</span>

        <span class="c"># create distribution objects</span>
        <span class="n">binary</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">binary</span><span class="p">(</span><span class="n">mix</span><span class="o">=</span><span class="n">mix</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">coup</span><span class="o">*</span><span class="n">mom</span><span class="p">,</span> <span class="n">copies</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">box</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">copies</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">box</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">copies</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">pot</span><span class="p">,</span> <span class="s">&#39;__call__&#39;</span><span class="p">):</span>  <span class="c"># if isinstance(pot, dist.Distribution)</span>
            <span class="n">pot</span><span class="o">.</span><span class="n">copies</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

        <span class="c"># define potentials (V_i +- J_i*S*cos(theta_i))</span>
        <span class="n">up</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">add_ent</span><span class="p">(</span><span class="n">pot</span><span class="o">=-</span><span class="n">binary</span><span class="o">*</span><span class="n">dist</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">+</span><span class="n">pot</span><span class="p">)</span>
        <span class="n">down</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">add_ent</span><span class="p">(</span><span class="n">pot</span><span class="o">=</span><span class="n">binary</span><span class="o">*</span><span class="n">dist</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">+</span><span class="n">pot</span><span class="p">)</span>

        <span class="c"># define on-site interaction (spin-flip)</span>
        <span class="n">site</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">down</span><span class="p">,</span> <span class="n">up</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">binary</span><span class="o">*</span><span class="n">dist</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">dist</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">phi</span><span class="o">*</span><span class="mi">1j</span><span class="p">))</span>
        <span class="n">site</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">up</span><span class="p">,</span> <span class="n">down</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">binary</span><span class="o">*</span><span class="n">dist</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">dist</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">phi</span><span class="o">*</span><span class="mi">1j</span><span class="p">))</span>

        <span class="c"># define next-neighbor interaction</span>
        <span class="n">nei</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">add_neigh</span><span class="p">()</span>
        <span class="n">nei</span><span class="o">.</span><span class="n">add_vect</span><span class="p">(</span><span class="n">permall</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">nei</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">up</span><span class="p">,</span> <span class="n">up</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">)</span>
        <span class="n">nei</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">down</span><span class="p">,</span> <span class="n">down</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">)</span>
        <span class="c">#print &#39;sizeof(neigh):&#39;, asizeof.asizeof(neigh)</span>

        <span class="c"># return reference to the lattice object</span>
        <span class="k">return</span> <span class="n">lat</span>
</div>
<div class="viewcode-block" id="SuperCell.add_andheis"><a class="viewcode-back" href="../../sc.html#tb.sc.SuperCell.add_andheis">[docs]</a>    <span class="k">def</span> <span class="nf">add_andheis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pot</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">hop</span><span class="o">=-</span><span class="mf">1.</span><span class="p">,</span> <span class="n">coup</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">mom</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">mix</span><span class="o">=.</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">shape</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">bcond</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">bvects</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                    <span class="n">label</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implement Anderson-Heisenberg model with classical impurity spins.</span>
<span class="sd">        This is the isotropic version, where all spin directions have equal</span>
<span class="sd">        probability (SU2-invariant).</span>

<span class="sd">        coup: exchange couplings J between conduction electrons and local</span>
<span class="sd">              magnetic moments</span>
<span class="sd">        mom:  magnetic moment of each impurity</span>
<span class="sd">        mix:  impurity concentration&quot;&quot;&quot;</span>
        <span class="c"># 2013-06-27 - 2013-06-27</span>
        <span class="c"># based on tb.sc.SuperCell.add_andheis (2012-08-04 - 2012-08-21)</span>

        <span class="c"># create lattice</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_lat</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">bcond</span><span class="o">=</span><span class="n">bcond</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">,</span>
                           <span class="n">bvects</span><span class="o">=</span><span class="n">bvects</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>  <span class="c"># diaghops=True</span>
        <span class="n">site</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">add_site</span><span class="p">()</span>

        <span class="c"># evaluate mathematical expressions</span>
        <span class="n">coup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalmath</span><span class="p">(</span><span class="n">coup</span><span class="p">)</span>
        <span class="n">mix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalmath</span><span class="p">(</span><span class="n">mix</span><span class="p">)</span>
        <span class="n">mom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalmath</span><span class="p">(</span><span class="n">mom</span><span class="p">)</span>

        <span class="c"># create distribution objects</span>
        <span class="n">binary</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">binary</span><span class="p">(</span><span class="n">mix</span><span class="o">=</span><span class="n">mix</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">coup</span><span class="o">*</span><span class="n">mom</span><span class="p">,</span> <span class="n">copies</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">costheta</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">box</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">copies</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">box</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">copies</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">pot</span><span class="p">,</span> <span class="s">&#39;__call__&#39;</span><span class="p">):</span>  <span class="c"># if isinstance(pot, dist.Distribution)</span>
            <span class="n">pot</span><span class="o">.</span><span class="n">copies</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

        <span class="c"># define potentials (V_i +- J_i*S*cos(theta_i))</span>
        <span class="n">up</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">add_ent</span><span class="p">(</span><span class="n">pot</span><span class="o">=-</span><span class="n">binary</span><span class="o">*</span><span class="n">costheta</span><span class="o">+</span><span class="n">pot</span><span class="p">)</span>
        <span class="n">down</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">add_ent</span><span class="p">(</span><span class="n">pot</span><span class="o">=</span><span class="n">binary</span><span class="o">*</span><span class="n">costheta</span><span class="o">+</span><span class="n">pot</span><span class="p">)</span>

        <span class="c"># define on-site interaction (spin-flip)</span>
        <span class="n">site</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">down</span><span class="p">,</span> <span class="n">up</span><span class="p">,</span>
                     <span class="n">hop</span><span class="o">=</span><span class="n">binary</span><span class="o">*</span><span class="n">dist</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">dist</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">costheta</span><span class="p">))</span> <span class="o">*</span>
                     <span class="n">dist</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">phi</span><span class="o">*</span><span class="mi">1j</span><span class="p">))</span>
        <span class="n">site</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">up</span><span class="p">,</span> <span class="n">down</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">binary</span><span class="o">*</span><span class="n">dist</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">dist</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">costheta</span><span class="p">))</span>
                     <span class="o">*</span> <span class="n">dist</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">phi</span><span class="o">*</span><span class="mi">1j</span><span class="p">))</span>

        <span class="c"># define next-neighbor interaction</span>
        <span class="n">nei</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">add_neigh</span><span class="p">()</span>
        <span class="n">nei</span><span class="o">.</span><span class="n">add_vect</span><span class="p">(</span><span class="n">permall</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">nei</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">up</span><span class="p">,</span> <span class="n">up</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">)</span>
        <span class="n">nei</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">down</span><span class="p">,</span> <span class="n">down</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">)</span>
        <span class="c">#print &#39;sizeof(neigh):&#39;, asizeof.asizeof(neigh)</span>

        <span class="c"># return reference to the lattice object</span>
        <span class="k">return</span> <span class="n">lat</span>
</div>
<div class="viewcode-block" id="SuperCell.is_complex"><a class="viewcode-back" href="../../sc.html#tb.sc.SuperCell.is_complex">[docs]</a>    <span class="k">def</span> <span class="nf">is_complex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check whether this supercell contains any complex potentials or</span>
<span class="sd">        hoppings.&quot;&quot;&quot;</span>
        <span class="c"># 2011-08-22 - 2012-08-01</span>
        <span class="k">for</span> <span class="n">lat</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lats</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">lat</span><span class="o">.</span><span class="n">is_complex</span><span class="p">():</span>
                <span class="k">return</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">site</span><span class="o">.</span><span class="n">is_complex</span><span class="p">():</span>
                <span class="k">return</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">hop</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hops</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">scipy</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">hop</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>
</div>
<div class="viewcode-block" id="SuperCell.size"><a class="viewcode-back" href="../../sc.html#tb.sc.SuperCell.size">[docs]</a>    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return number of unitcells of all lattices.&quot;&quot;&quot;</span>
        <span class="c"># 2011-11-29</span>
        <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">lat</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lats</span><span class="p">:</span>
            <span class="n">total</span> <span class="o">+=</span> <span class="n">lat</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">total</span>
</div>
<div class="viewcode-block" id="SuperCell.nsites"><a class="viewcode-back" href="../../sc.html#tb.sc.SuperCell.nsites">[docs]</a>    <span class="k">def</span> <span class="nf">nsites</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return number of sites, including single sites as well as those of</span>
<span class="sd">        all the lattices.&quot;&quot;&quot;</span>
        <span class="c"># 2011-11-29 - 2012-02-24</span>
        <span class="n">total</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">lat</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lats</span><span class="p">:</span>
            <span class="n">total</span> <span class="o">+=</span> <span class="n">lat</span><span class="o">.</span><span class="n">nsites</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">total</span>
</div>
<div class="viewcode-block" id="SuperCell.nents"><a class="viewcode-back" href="../../sc.html#tb.sc.SuperCell.nents">[docs]</a>    <span class="k">def</span> <span class="nf">nents</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return number of entities of all lattices and all sites. Equals the</span>
<span class="sd">        rank of the tight binding matrix.&quot;&quot;&quot;</span>
        <span class="c"># 2012-02-24</span>
        <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">:</span>
            <span class="n">total</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">ents</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">lat</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lats</span><span class="p">:</span>
            <span class="n">uctotal</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">lat</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">sites</span><span class="p">:</span>
                <span class="n">uctotal</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">ents</span><span class="p">)</span>
            <span class="n">total</span> <span class="o">+=</span> <span class="n">uctotal</span><span class="o">*</span><span class="n">scipy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">lat</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">total</span>
</div>
<div class="viewcode-block" id="SuperCell.get_lat"><a class="viewcode-back" href="../../sc.html#tb.sc.SuperCell.get_lat">[docs]</a>    <span class="k">def</span> <span class="nf">get_lat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get lattice by label.&quot;&quot;&quot;</span>
        <span class="c"># 2011-12-18</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">lat</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lats</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">lat</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="n">label</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">lat</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s">&#39;lattice with label </span><span class="si">%s</span><span class="s"> not found&#39;</span> <span class="o">%</span> <span class="n">label</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>
</div>
<div class="viewcode-block" id="SuperCell.coords"><a class="viewcode-back" href="../../sc.html#tb.sc.SuperCell.coords">[docs]</a>    <span class="k">def</span> <span class="nf">coords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the coordinates of all the sites (also from all lattice</span>
<span class="sd">        sites).&quot;&quot;&quot;</span>
        <span class="c"># 2012-04-05</span>
        <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">site</span><span class="o">.</span><span class="n">coord</span>
        <span class="k">for</span> <span class="n">lat</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lats</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">lat</span><span class="o">.</span><span class="n">coords</span><span class="p">():</span>
                <span class="k">yield</span> <span class="n">coord</span>

</div></div>
<div class="viewcode-block" id="LatticeObject"><a class="viewcode-back" href="../../sc.html#tb.sc.LatticeObject">[docs]</a><span class="k">class</span> <span class="nc">LatticeObject</span><span class="p">(</span><span class="n">SuperCellObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Define shared methods and attributes of the lattice classes (so far:</span>
<span class="sd">    Lattice and SparseLattice.&quot;&quot;&quot;</span>
    <span class="c"># 2012-05-01</span>
    <span class="c"># copied from tb.sc.Lattice from 2011-08-11 - 2012-04-05</span>
    <span class="c"># former tb.Lattice from 2011-03-05 - 2011-03-31</span>

<div class="viewcode-block" id="LatticeObject.is_complex"><a class="viewcode-back" href="../../sc.html#tb.sc.LatticeObject.is_complex">[docs]</a>    <span class="k">def</span> <span class="nf">is_complex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check whether this lattice has complex potentials or hoppings.&quot;&quot;&quot;</span>
        <span class="c"># 2011-08-20 - 2011-08-23</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">is_complex</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">neigh</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">neigh</span><span class="o">.</span><span class="n">is_complex</span><span class="p">():</span>
                <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>
</div>
<div class="viewcode-block" id="LatticeObject.is_symmetric"><a class="viewcode-back" href="../../sc.html#tb.sc.LatticeObject.is_symmetric">[docs]</a>    <span class="k">def</span> <span class="nf">is_symmetric</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if tight binding matrix is symmetric.&quot;&quot;&quot;</span>
        <span class="c"># 2011-08-25 - 2012-03-02</span>
        <span class="c"># Convert the matrix to the dok-format before comparison</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tbmat</span><span class="p">()</span>  <span class="c"># cache=True</span>
        <span class="k">return</span> <span class="n">mat</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">todok</span><span class="p">()</span> <span class="o">==</span> <span class="n">mat</span><span class="o">.</span><span class="n">todok</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="LatticeObject.is_hermitian"><a class="viewcode-back" href="../../sc.html#tb.sc.LatticeObject.is_hermitian">[docs]</a>    <span class="k">def</span> <span class="nf">is_hermitian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if tight binding matrix is hermitian.&quot;&quot;&quot;</span>
        <span class="c"># 2011-08-25 - 2012-03-02</span>
        <span class="c"># Convert the matrix to the dok-format before comparison</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tbmat</span><span class="p">()</span>  <span class="c"># cache=True</span>
        <span class="k">return</span> <span class="n">mat</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">todok</span><span class="p">()</span> <span class="o">==</span> <span class="n">mat</span><span class="o">.</span><span class="n">todok</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="LatticeObject.nsites"><a class="viewcode-back" href="../../sc.html#tb.sc.LatticeObject.nsites">[docs]</a>    <span class="k">def</span> <span class="nf">nsites</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return number of sites.&quot;&quot;&quot;</span>
        <span class="c"># 2011-11-29</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">()</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">nsites</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="LatticeObject.get_neigh"><a class="viewcode-back" href="../../sc.html#tb.sc.LatticeObject.get_neigh">[docs]</a>    <span class="k">def</span> <span class="nf">get_neigh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get neighbor by label.&quot;&quot;&quot;</span>
        <span class="c"># 2011-12-18</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">neigh</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">neigh</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="n">label</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">neigh</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s">&#39;neighbor with label </span><span class="si">%s</span><span class="s"> not found&#39;</span> <span class="o">%</span> <span class="n">label</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>
</div>
<div class="viewcode-block" id="LatticeObject.add_neigh"><a class="viewcode-back" href="../../sc.html#tb.sc.LatticeObject.add_neigh">[docs]</a>    <span class="k">def</span> <span class="nf">add_neigh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">neighs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a neighbor interaction object to the lattice that may connect</span>
<span class="sd">        several unitcells defined by relative vectors. For a complete list of</span>
<span class="sd">        possible arguments, look at the definition of Neighbor.__init__.</span>

<span class="sd">        Also, predefined neighbor objects may be given as positional arguments.</span>
<span class="sd">        Then, no keyword arguments may be given.&quot;&quot;&quot;</span>
        <span class="c"># 2011-08-20 - 2012-05-01</span>

        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">neighs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">unitcell</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">unitcell</span><span class="p">)</span>
            <span class="n">neigh</span> <span class="o">=</span> <span class="n">Neighbor</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">neighs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neigh</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">neigh</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s">&#39;no keyword arguments allowed if positional &#39;</span> <span class="o">+</span>
                               <span class="s">&#39;arguments are given&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">neigh</span> <span class="ow">in</span> <span class="n">neighs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">neigh</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighs</span><span class="p">:</span>
                    <span class="n">neigh</span><span class="o">.</span><span class="n">unitcell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unitcell</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">neighs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neigh</span><span class="p">)</span>

</div></div>
<div class="viewcode-block" id="Lattice"><a class="viewcode-back" href="../../sc.html#tb.sc.Lattice">[docs]</a><span class="k">class</span> <span class="nc">Lattice</span><span class="p">(</span><span class="n">LatticeObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Define a regular lattice, using a unitcell that may contain multiple</span>
<span class="sd">    sites and is repeated periodically in space a given number of times in each</span>
<span class="sd">    dimension.&quot;&quot;&quot;</span>
    <span class="c"># 2011-08-11 - 2013-07-07</span>
    <span class="c"># former tb.Lattice from 2011-03-05 - 2011-03-31</span>

    <span class="c"># initialize instance counter</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">bcond</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">bvects</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">label</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">neighs</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">diaghops</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize lattice object.&quot;&quot;&quot;</span>
        <span class="c"># 2011-08-11 - 2013-07-07</span>

        <span class="c"># number of dimensions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalmath</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;number of dimensions must be positive integer&#39;</span>

        <span class="c"># shape</span>
        <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;,&#39;</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;shape must consist of positive integers&#39;</span>

        <span class="c"># boundary conditions</span>
        <span class="k">if</span> <span class="n">bcond</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bcond</span> <span class="o">=</span> <span class="s">&#39;p&#39;</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bcond</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">bcond</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">bcond</span> <span class="o">!=</span> <span class="s">&#39;&#39;</span><span class="p">,</span> <span class="s">&#39;no boundary conditions given&#39;</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bcond</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bcond</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bcond</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c"># origin</span>
        <span class="k">if</span> <span class="n">origin</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.</span><span class="p">,)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">origin</span><span class="p">)</span>

        <span class="c"># basis vectors that span the lattice within the supercell</span>
        <span class="k">if</span> <span class="n">bvects</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bvects</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bvects</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bvects</span><span class="p">)</span>

        <span class="c"># list of inter-cell hoppings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">neighs</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">neighs</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">neighs</span>

        <span class="c"># create unitcell</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unitcell</span> <span class="o">=</span> <span class="n">UnitCell</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">uc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unitcell</span>  <span class="c"># shortcut</span>

        <span class="c"># set label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%s%i</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ucletters</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">),</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">label</span>

        <span class="c"># initialize switches</span>
        <span class="c">#self.longhops = longhops  # allow long hoppings circling the lattice</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">diaghops</span> <span class="o">=</span> <span class="n">diaghops</span>  <span class="c"># put real part of negative hoppings on</span>
                                  <span class="c"># diagonal</span>

<div class="viewcode-block" id="Lattice.size"><a class="viewcode-back" href="../../sc.html#tb.sc.Lattice.size">[docs]</a>    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return number of unitcells.&quot;&quot;&quot;</span>
        <span class="c"># 2011-08-21 - 2011-10-12</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Lattice.ndindex2index"><a class="viewcode-back" href="../../sc.html#tb.sc.Lattice.ndindex2index">[docs]</a>    <span class="k">def</span> <span class="nf">ndindex2index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndindex</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return index of the given n-dimensional index that it would have in</span>
<span class="sd">        the n-dimensional index list provided by scipy.ndindex. If ndindex is a</span>
<span class="sd">        2D array, each row is treated as an n-dimensional index, and the result</span>
<span class="sd">        will be a 1D array of indices.  Can also be given a list of nd-indices</span>
<span class="sd">        (2d-array).&quot;&quot;&quot;</span>
        <span class="c"># 2011-08-23 - 2012-09-03</span>
        <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ndindex</span><span class="p">,</span> <span class="n">scipy</span><span class="o">.</span><span class="n">cumprod</span><span class="p">((</span><span class="mi">1</span><span class="p">,)</span><span class="o">+</span><span class="n">shape</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="o">-</span><span class="mi">2</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="c">### The look-up table could better be calculated once, and not be</span>
        <span class="c">### re-calculated for every vector, because it is universal!</span>
</div>
<div class="viewcode-block" id="Lattice.indmat"><a class="viewcode-back" href="../../sc.html#tb.sc.Lattice.indmat">[docs]</a>    <span class="k">def</span> <span class="nf">indmat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vects</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return index matrix. Format will be coordinate sparse format (coo).</span>
<span class="sd">        It will contain ones for those blocks that have to be set to enable</span>
<span class="sd">        hopping in the direction of the given vector (vect), and zeros</span>
<span class="sd">        elsewhere.&quot;&quot;&quot;</span>
        <span class="c"># 2011-08-25</span>

        <span class="c"># get all unitcell coordinates (integer)</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>

        <span class="c"># initialize lists that hold the indices of the blocks where the</span>
        <span class="c"># submatrix of this neighbor interaction will be put</span>
        <span class="n">rowind</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">colind</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">signchanges</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c"># determine the indices of the blocks where to put the hopping matrix</span>
        <span class="c"># of the neighbor interaction object</span>
        <span class="k">for</span> <span class="n">vect</span> <span class="ow">in</span> <span class="n">vects</span><span class="p">:</span>
            <span class="c"># Get coordinates shifted by this vector</span>
            <span class="n">shifted</span> <span class="o">=</span> <span class="n">coords</span><span class="o">+</span><span class="n">vect</span>

            <span class="c"># determine number of sign changes (if antiperiodic boundary</span>
            <span class="c"># conditions are used)</span>
            <span class="n">cdiv</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">shifted</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

            <span class="c"># wrap shifted coordinates around so that they do not lie outside</span>
            <span class="c"># the lattice</span>
            <span class="n">shifted</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">shifted</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

            <span class="c"># calculate which indices the shifted coordinates would have in the</span>
            <span class="c"># normal coordinates list</span>
            <span class="n">newrowinds</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">newcolinds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndindex2index</span><span class="p">(</span><span class="n">shifted</span><span class="p">)</span>

            <span class="c"># Debugging checks</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">newrowinds</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">newcolinds</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>

            <span class="c"># respect boundary conditions</span>
            <span class="n">donotuse</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">nosc</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>  <span class="c"># number of sign</span>
                                                        <span class="c"># changes</span>
            <span class="k">for</span> <span class="n">dind</span><span class="p">,</span> <span class="n">bc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bcond</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">bc</span> <span class="o">==</span> <span class="s">&#39;s&#39;</span><span class="p">:</span>
                    <span class="c"># if a dimension has a static boundary condition and cdiv</span>
                    <span class="c"># is not zero, do not set those blocks</span>
                    <span class="n">donotuse</span> <span class="o">+=</span> <span class="n">cdiv</span><span class="p">[:,</span> <span class="n">dind</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span>
                <span class="k">elif</span> <span class="n">bc</span> <span class="o">==</span> <span class="s">&#39;a&#39;</span><span class="p">:</span>
                    <span class="c"># For every dimension with antiperiodic boundary condition,</span>
                    <span class="c"># change the sign of the blocks a certain number of times</span>
                    <span class="c"># according to cdiv</span>
                    <span class="n">nosc</span> <span class="o">+=</span> <span class="n">cdiv</span><span class="p">[:,</span> <span class="n">dind</span><span class="p">]</span>

            <span class="c"># append the indices and sign changes to the big index lists</span>
            <span class="n">rowind</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">newrowinds</span><span class="p">[</span><span class="n">donotuse</span> <span class="o">==</span> <span class="bp">False</span><span class="p">])</span>  <span class="c"># &quot;is False&quot; does</span>
            <span class="n">colind</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">newcolinds</span><span class="p">[</span><span class="n">donotuse</span> <span class="o">==</span> <span class="bp">False</span><span class="p">])</span>  <span class="c"># not work</span>
            <span class="n">signchanges</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nosc</span><span class="p">[</span><span class="n">donotuse</span> <span class="o">==</span> <span class="bp">False</span><span class="p">])</span>

        <span class="c"># debugging checks</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">rowind</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">colind</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">rowind</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">signchanges</span><span class="p">)</span>

        <span class="c"># construct index matrix. It defines where and with which sign the</span>
        <span class="c"># hopping submatrix of this neighbor interaction will go.</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">(((</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">signchanges</span><span class="p">),</span>
                                        <span class="p">(</span><span class="n">rowind</span><span class="p">,</span> <span class="n">colind</span><span class="p">)),</span>
                                       <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">(),)</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Lattice.tbmat"><a class="viewcode-back" href="../../sc.html#tb.sc.Lattice.tbmat">[docs]</a>    <span class="k">def</span> <span class="nf">tbmat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return tight binding matrix of this lattice, convert to the</span>
<span class="sd">        specified format (one of dense, csr, csc, dok, coo, dia, bsr, or</span>
<span class="sd">        lil).&quot;&quot;&quot;</span>
        <span class="c"># 2011-08-20 - 2012-08-01</span>

        <span class="c"># get index of each entity</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">ent</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">ents</span><span class="p">()):</span>
            <span class="n">inds</span><span class="p">[</span><span class="n">ent</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind</span>

        <span class="c"># create matrix and set blocks on the main diagonal</span>
        <span class="c">#print time.ctime(), \</span>
                <span class="c">#&#39;create matrix of lattice and set diagonal blocks...&#39;</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">(),)</span><span class="o">*</span><span class="mi">2</span><span class="p">)),</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">tbmat</span><span class="p">())</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">infertype</span><span class="p">())</span>
        <span class="c">#print time.ctime(), &#39;matrix of lattice created, diagonal blocks set&#39;</span>

        <span class="c"># set random potentials and hoppings within the blocks on the main</span>
        <span class="c"># diagonal</span>
        <span class="c">#print time.ctime(), \</span>
                <span class="c">#&#39;set diagonal random matrix elements of lattice...&#39;</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">todok</span><span class="p">()</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">ent1</span><span class="p">,</span> <span class="n">ent2</span><span class="p">),</span> <span class="n">hop</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>  <span class="c"># new=False</span>
            <span class="c"># define some shortcuts</span>
            <span class="n">ne</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">ents</span><span class="p">()))</span>  <span class="c"># number of entities</span>
            <span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>  <span class="c"># number of cells</span>

            <span class="c"># generate random variates</span>
            <span class="n">variates</span> <span class="o">=</span> <span class="n">hop</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>

            <span class="c"># add these random hopping parameters to the big matrix</span>
            <span class="n">helper</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">(([</span><span class="mi">1</span><span class="p">],</span> <span class="p">([</span><span class="n">inds</span><span class="p">[</span><span class="n">ent1</span><span class="p">]],</span>
                                              <span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">ent2</span><span class="p">]])),</span>
                                             <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">ne</span><span class="p">,</span> <span class="n">ne</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">diag</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">spdiags</span><span class="p">([</span><span class="n">variates</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
            <span class="n">mat</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">diag</span><span class="p">,</span> <span class="n">helper</span><span class="p">)</span><span class="o">.</span><span class="n">todok</span><span class="p">())</span>

            <span class="c">### old method. Problem: &quot;+=&quot; only works with lil</span>
            <span class="c">#self._tbmat[inds[ent1]::ne, inds[ent2]::ne] += spdiags([variates],</span>
                                                                    <span class="c">#[0], size,</span>
                                                                    <span class="c">#size)</span>
        <span class="c">#print time.ctime(), &#39;diagonal random matrix elements of lattice set&#39;</span>

        <span class="c"># set off-diagonal blocks with submatrix</span>
        <span class="c">#print time.ctime(), &#39;set off-diagonal blocks of lattice...&#39;</span>
        <span class="k">for</span> <span class="n">neigh</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighs</span><span class="p">:</span>
            <span class="c"># get index matrix, indicating the blocks that have to be set to</span>
            <span class="c"># enable hopping for this neighbor interaction</span>
            <span class="n">indmat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indmat</span><span class="p">(</span><span class="n">neigh</span><span class="o">.</span><span class="n">vects</span><span class="p">)</span>
            <span class="n">isoindmat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indmat</span><span class="p">(</span><span class="n">neigh</span><span class="o">.</span><span class="n">isovects</span><span class="p">)</span>

            <span class="c"># set certain blocks of the big matrix with the hopping matrix of</span>
            <span class="c"># this neighbor interaction object</span>
            <span class="n">submat</span> <span class="o">=</span> <span class="n">neigh</span><span class="o">.</span><span class="n">tbmat</span><span class="p">()</span>
            <span class="n">helper3</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">indmat</span><span class="p">,</span> <span class="n">submat</span><span class="p">)</span><span class="o">.</span><span class="n">todok</span><span class="p">()</span>
            <span class="n">mat</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">helper3</span><span class="p">)</span>

            <span class="c"># set certain blocks of the big matrix with the adjoint of this</span>
            <span class="c"># hopping matrix</span>
            <span class="n">adjoint</span> <span class="o">=</span> <span class="n">submat</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span>
            <span class="c">#mat.update(scipy.sparse.kron(isoindmat, adjoint).todok())</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="n">mat</span> <span class="o">+</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">isoindmat</span><span class="p">,</span> <span class="n">adjoint</span><span class="p">)</span><span class="o">.</span><span class="n">todok</span><span class="p">()</span>

            <span class="c"># add the negative real part of each off-diagonal block to the</span>
            <span class="c"># corresponding diagonal block in the same row</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">diaghops</span><span class="p">:</span>
                <span class="n">add2diag</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">helper3</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">real</span>
                <span class="n">add2mat</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">dok_matrix</span><span class="p">(</span><span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">add2mat</span><span class="o">.</span><span class="n">setdiag</span><span class="p">(</span><span class="n">add2diag</span><span class="p">)</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="n">mat</span> <span class="o">-</span> <span class="n">add2mat</span>

            <span class="c"># set random matrix elements for this hopping matrix</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">ent1</span><span class="p">,</span> <span class="n">ent2</span><span class="p">),</span> <span class="n">hop</span> <span class="ow">in</span> <span class="n">neigh</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                <span class="c"># generate random variates</span>
                <span class="k">if</span> <span class="n">indmat</span><span class="o">.</span><span class="n">nnz</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">indmat</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">hop</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">indmat</span><span class="o">.</span><span class="n">nnz</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">isoindmat</span><span class="o">.</span><span class="n">nnz</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">isoindmat</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">hop</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">isoindmat</span><span class="o">.</span><span class="n">nnz</span><span class="p">)</span>

                <span class="c"># define shortcuts</span>
                <span class="n">ne</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">ents</span><span class="p">()))</span>  <span class="c"># number of entities</span>

                <span class="c"># add these random hopping parameters to the big matrix</span>
                <span class="n">helper</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">(([</span><span class="mi">1</span><span class="p">],</span> <span class="p">([</span><span class="n">inds</span><span class="p">[</span><span class="n">ent1</span><span class="p">]],</span>
                                                  <span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">ent2</span><span class="p">]])),</span>
                                                 <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">ne</span><span class="p">,</span> <span class="n">ne</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                <span class="n">helper2</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">indmat</span><span class="p">,</span> <span class="n">helper</span><span class="p">)</span><span class="o">.</span><span class="n">todok</span><span class="p">()</span>
                <span class="c">#mat.update(helper2)</span>
                <span class="c">#mat.update(scipy.sparse.kron(isoindmat, helper).todok())</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="n">mat</span> <span class="o">+</span> <span class="n">helper2</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="n">mat</span> <span class="o">+</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">isoindmat</span><span class="p">,</span> <span class="n">helper</span><span class="p">)</span><span class="o">.</span><span class="n">todok</span><span class="p">()</span>

                <span class="c"># add the negative real part of each off-diagonal block to the</span>
                <span class="c"># corresponding diagonal block in the same row</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">diaghops</span><span class="p">:</span>
                    <span class="n">add2diag</span> <span class="o">=</span> \
                        <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">helper2</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">real</span><span class="o">/</span><span class="mi">2</span>
                    <span class="n">add2mat</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">dok_matrix</span><span class="p">(</span><span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                    <span class="n">add2mat</span><span class="o">.</span><span class="n">setdiag</span><span class="p">(</span><span class="n">add2diag</span><span class="p">)</span>
                    <span class="n">mat</span> <span class="o">=</span> <span class="n">mat</span><span class="o">-</span><span class="n">add2mat</span>
        <span class="c">#print time.ctime(), &#39;off-diagonal blocks of lattice set&#39;</span>

        <span class="c"># convert to CSR sparse format by default</span>
        <span class="k">if</span> <span class="n">format</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">format</span> <span class="o">=</span> <span class="s">&#39;csr&#39;</span>

        <span class="c"># return matrix</span>
        <span class="k">return</span> <span class="n">mat</span><span class="o">.</span><span class="n">asformat</span><span class="p">(</span><span class="n">format</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Lattice.coords"><a class="viewcode-back" href="../../sc.html#tb.sc.Lattice.coords">[docs]</a>    <span class="k">def</span> <span class="nf">coords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the coordinates of all the sites.&quot;&quot;&quot;</span>
        <span class="c"># 2012-04-05 - 2012-05-01</span>
        <span class="k">for</span> <span class="n">vect</span> <span class="ow">in</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">sites</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span>
                <span class="c">#yield tuple(self.origin+scipy.dot(self.bvects, vect))</span>

</div></div>
<div class="viewcode-block" id="UnitCell"><a class="viewcode-back" href="../../sc.html#tb.sc.UnitCell">[docs]</a><span class="k">class</span> <span class="nc">UnitCell</span><span class="p">(</span><span class="n">SuperCellObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Define the unitcell of a lattice. May contain several sites.&quot;&quot;&quot;</span>
    <span class="c"># 2011-08-21 - 2012-03-02</span>

    <span class="c"># initialize instance counter</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">sites</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">hops</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize unitcell.&quot;&quot;&quot;</span>
        <span class="c"># 2011-08-21 - 2012-03-02</span>

        <span class="c"># number of dimensions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalmath</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;number of dimensions must be positive integer&#39;</span>

        <span class="c"># data structures</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sites</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">sites</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">sites</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hops</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">hops</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">hops</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c"># set label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%s%i</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ucletters</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">),</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">label</span>

<div class="viewcode-block" id="UnitCell.ents"><a class="viewcode-back" href="../../sc.html#tb.sc.UnitCell.ents">[docs]</a>    <span class="k">def</span> <span class="nf">ents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sites</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return all entities of all sites that exist in this unitcell. If</span>
<span class="sd">        sites is True, also return the site where the entity is located.&quot;&quot;&quot;</span>
        <span class="c"># 2011-08-22 - 2011-09-02</span>
        <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="n">site</span><span class="o">.</span><span class="n">ents</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">sites</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">ent</span><span class="p">,</span> <span class="n">site</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">ent</span>
</div>
<div class="viewcode-block" id="UnitCell.add_site"><a class="viewcode-back" href="../../sc.html#tb.sc.UnitCell.add_site">[docs]</a>    <span class="k">def</span> <span class="nf">add_site</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">sites</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a site to the unitcell at the given coordinates (coord). The</span>
<span class="sd">        coordinates should be given as relative values from the range [0, 1].</span>
<span class="sd">        For a complete list of possible arguments, look at the definition of</span>
<span class="sd">        Site.__init__.</span>

<span class="sd">        Also, predefined site objects may be given as positional arguments.</span>
<span class="sd">        Then, no keyword arguments may be given.&quot;&quot;&quot;</span>
        <span class="c"># 2011-08-20 - 2012-05-01</span>

        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sites</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">site</span> <span class="o">=</span> <span class="n">Site</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">site</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">site</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s">&#39;no keyword arguments allowed if positional &#39;</span> <span class="o">+</span>
                               <span class="s">&#39;arguments are given&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">sites</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">site</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">site</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="UnitCell.add_hop"><a class="viewcode-back" href="../../sc.html#tb.sc.UnitCell.add_hop">[docs]</a>    <span class="k">def</span> <span class="nf">add_hop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">ents</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a hopping between the given entities. All entities must already</span>
<span class="sd">        exist in the list of entities of this unitcell. The hopping parameter</span>
<span class="sd">        can either be a constant or drawn from a probability distribution. The</span>
<span class="sd">        interaction may be defined as isotropic (iso), meaning that also</span>
<span class="sd">        hopping in the opposite direction will be allowed.</span>

<span class="sd">        Notes:</span>
<span class="sd">        --&gt; Should check if both entities are of the same site. If so, hand</span>
<span class="sd">            task off to Site.add_hop.&quot;&quot;&quot;</span>
        <span class="c"># 2011-09-06 - 2011-11-09</span>

        <span class="c"># make sure all entities exist at this site</span>
        <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="n">ents</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">ent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ents</span><span class="p">(),</span> \
                <span class="s">&#39;Entity </span><span class="si">%s</span><span class="s"> does not exist at this site&#39;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="n">ent</span><span class="p">)</span>

        <span class="c"># handle multiple entities</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ents</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;at least two entities have to be given&#39;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ents</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ent1</span><span class="p">,</span> <span class="n">ent2</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">ents</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">ent1</span><span class="p">,</span> <span class="n">ent2</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ent1</span><span class="p">,</span> <span class="n">ent2</span> <span class="o">=</span> <span class="n">ents</span>

            <span class="c"># get keyword arguments</span>
            <span class="n">hop</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;hop&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">)</span>
            <span class="c">#dist = kwargs.get(&#39;dist&#39;, None)</span>
            <span class="c">#loc = kwargs.get(&#39;loc&#39;, 0.)</span>
            <span class="c">#scale = kwargs.get(&#39;scale&#39;, 1.)</span>
            <span class="n">iso</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;iso&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>

            <span class="c"># check if the two entities are identical</span>
            <span class="k">if</span> <span class="n">ent1</span> <span class="o">==</span> <span class="n">ent2</span><span class="p">:</span>
                <span class="c"># then just redefine the potential of that entity</span>
                <span class="n">ent1</span><span class="o">.</span><span class="n">pot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalmath</span><span class="p">(</span><span class="n">hop</span><span class="p">)</span>
                <span class="k">return</span>

            <span class="c"># just delete if zero is given</span>
            <span class="k">if</span> <span class="n">hop</span> <span class="o">==</span> <span class="mf">0.</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ent1</span><span class="p">,</span> <span class="n">ent2</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hops</span><span class="p">:</span>
                <span class="k">del</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hops</span><span class="p">[</span><span class="n">ent1</span><span class="p">,</span> <span class="n">ent2</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">hops</span><span class="p">[</span><span class="n">ent1</span><span class="p">,</span> <span class="n">ent2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalmath</span><span class="p">(</span><span class="n">hop</span><span class="p">)</span>
                <span class="c"># dict(dist=dist, loc=self.evalmath(loc),</span>
                <span class="c"># scale=self.evalmath(scale))</span>

            <span class="c"># isotropic hopping?</span>
            <span class="k">if</span> <span class="n">iso</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">ent2</span><span class="p">,</span> <span class="n">ent1</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(),</span> <span class="n">iso</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                <span class="c"># dist=dist, loc=loc, scale=scale</span>
                <span class="c">### What happens if iso is True and hop is random?</span>
</div>
<div class="viewcode-block" id="UnitCell.tbmat"><a class="viewcode-back" href="../../sc.html#tb.sc.UnitCell.tbmat">[docs]</a>    <span class="k">def</span> <span class="nf">tbmat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>  <span class="c"># new=False, cache=False</span>
        <span class="sd">&quot;&quot;&quot;Return submatrix of the unitcell, convert to the specified format</span>
<span class="sd">        (one of dense, csr, csc, dok, coo, dia, bsr, or lil).  If new is True,</span>
<span class="sd">        recalculate the whole matrix, including the random hopping dictionary.</span>
<span class="sd">        If cache is True, always return the cached version of the matrix (if</span>
<span class="sd">        there is no cached version, raise an exception). If new and cache are</span>
<span class="sd">        False, calculate the submatrix only if there is no cached version,</span>
<span class="sd">        otherwise just return the cache.&quot;&quot;&quot;</span>
        <span class="c"># 2011-08-22 - 2012-01-24</span>

        <span class="c"># initialize data structures</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c"># get index of each entity</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">ent</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ents</span><span class="p">()):</span>
            <span class="n">inds</span><span class="p">[</span><span class="n">ent</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind</span>

        <span class="c"># first, fill all diagonal elements (potentials)</span>
        <span class="n">blocks</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> \
            <span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">site</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">):</span>
            <span class="n">blocks</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">tbmat</span><span class="p">()</span>  <span class="c"># new=new</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">random</span><span class="p">)</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">bmat</span><span class="p">(</span><span class="n">blocks</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;lil&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">infertype</span><span class="p">())</span>

        <span class="c"># then, fill all off-diagonal elements, containing hopping between the</span>
        <span class="c"># sites of the unitcell (intra-unitcell hopping)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">ent1</span><span class="p">,</span> <span class="n">ent2</span><span class="p">),</span> <span class="n">hop</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hops</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">hop</span><span class="p">,</span> <span class="s">&#39;__call__&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">random</span><span class="p">[</span><span class="n">ent1</span><span class="p">,</span> <span class="n">ent2</span><span class="p">]</span> <span class="o">=</span> <span class="n">hop</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mat</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">ent1</span><span class="p">],</span> <span class="n">inds</span><span class="p">[</span><span class="n">ent2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">hop</span>

        <span class="c"># return the matrix</span>
        <span class="k">return</span> <span class="n">mat</span><span class="o">.</span><span class="n">asformat</span><span class="p">(</span><span class="n">format</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="UnitCell.is_complex"><a class="viewcode-back" href="../../sc.html#tb.sc.UnitCell.is_complex">[docs]</a>    <span class="k">def</span> <span class="nf">is_complex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check whether this unitcell object contains complex potentials or</span>
<span class="sd">        hoppings.&quot;&quot;&quot;</span>
        <span class="c"># 2011-08-22 - 2012-08-01</span>
        <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">site</span><span class="o">.</span><span class="n">is_complex</span><span class="p">():</span>
                <span class="k">return</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">hop</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hops</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">hop</span><span class="p">,</span> <span class="s">&#39;__call__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">hop</span><span class="o">.</span><span class="n">is_complex</span><span class="p">():</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="k">elif</span> <span class="n">scipy</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">hop</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>
</div>
<div class="viewcode-block" id="UnitCell.nsites"><a class="viewcode-back" href="../../sc.html#tb.sc.UnitCell.nsites">[docs]</a>    <span class="k">def</span> <span class="nf">nsites</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return number of sites.&quot;&quot;&quot;</span>
        <span class="c"># 2011-11-29</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="UnitCell.get_site"><a class="viewcode-back" href="../../sc.html#tb.sc.UnitCell.get_site">[docs]</a>    <span class="k">def</span> <span class="nf">get_site</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get site by label.&quot;&quot;&quot;</span>
        <span class="c"># 2011-12-18</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">site</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="n">label</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">site</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s">&#39;site with label </span><span class="si">%s</span><span class="s"> not found&#39;</span> <span class="o">%</span> <span class="n">label</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

</div></div>
<div class="viewcode-block" id="Neighbor"><a class="viewcode-back" href="../../sc.html#tb.sc.Neighbor">[docs]</a><span class="k">class</span> <span class="nc">Neighbor</span><span class="p">(</span><span class="n">SuperCellObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Define interaction between different unitcells of a lattice.&quot;&quot;&quot;</span>
    <span class="c"># 2011-08-20 - 2012-05-01</span>
    <span class="c"># former tb.Neighbor from 2011-03-06 - 2011-03-31</span>
    <span class="c"># former tb.Neighbor from 2011-03-06 - 2011-03-31</span>

    <span class="c"># initialize instance counter</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">unitcell</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">hops</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">vects</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">isovects</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize neighbor interaction.&quot;&quot;&quot;</span>
        <span class="c"># 2011-08-20 - 2012-03-02</span>

        <span class="c"># number of dimensions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalmath</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;number of dimensions must be positive integer&#39;</span>

        <span class="c"># data structures</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unitcell</span> <span class="o">=</span> <span class="n">unitcell</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hops</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">hops</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">hops</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vects</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">vects</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">vects</span>  <span class="c"># list of integer vectors,</span>
                                                     <span class="c"># leading to those</span>
                                                     <span class="c"># neighbor unitcells that</span>
                                                     <span class="c"># should be set with the</span>
                                                     <span class="c"># hopping matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isovects</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">isovects</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">isovects</span>  <span class="c"># list of integer</span>
                                                              <span class="c"># vectors,</span>
                                                              <span class="c"># leading to</span>
                                                              <span class="c"># those neighbor</span>
                                                              <span class="c"># unitcells that</span>
                                                              <span class="c"># should be set</span>
                                                              <span class="c"># with the</span>
                                                              <span class="c"># adjoint hopping</span>
                                                              <span class="c"># matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c"># set label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%s%i</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ucletters</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">),</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">label</span>

<div class="viewcode-block" id="Neighbor.ents"><a class="viewcode-back" href="../../sc.html#tb.sc.Neighbor.ents">[docs]</a>    <span class="k">def</span> <span class="nf">ents</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the entities of all the sites of the unitcell.&quot;&quot;&quot;</span>
        <span class="c"># 2011-08-20 - 2011-08-22</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unitcell</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;no unitcell given&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">sites</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="n">site</span><span class="o">.</span><span class="n">ents</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">ent</span>
</div>
<div class="viewcode-block" id="Neighbor.add_hop"><a class="viewcode-back" href="../../sc.html#tb.sc.Neighbor.add_hop">[docs]</a>    <span class="k">def</span> <span class="nf">add_hop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">ents</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a hopping from entity 1 of the unitcell to entity 2 of each of</span>
<span class="sd">        the specified neighbor cells (which are specified by the given relative</span>
<span class="sd">        vectors). All entities must be defined within the unitcell of the</span>
<span class="sd">        lattice.  The hopping parameter can either be a constant or drawn from</span>
<span class="sd">        a probability distribution. The interaction may be defined as isotropic</span>
<span class="sd">        (iso), also allowing hopping from entity 2 to entity 1 (but still in</span>
<span class="sd">        the same direction, from this unitcell to the neighbor cell).</span>

<span class="sd">        If more than two entities are given, all combinations are added. If iso</span>
<span class="sd">        is True, even all permutations are added. Example with three entities</span>
<span class="sd">        e1, e2, e3: The possible combinations are (e1, e2), (e1, e3), (e2, e3).</span>
<span class="sd">        If iso is True, there will also be the hoppings (e3, e2), (e3, e1),</span>
<span class="sd">        (e2, e1).&quot;&quot;&quot;</span>
        <span class="c"># 2011-08-20 - 2012-05-01</span>

        <span class="c"># check if unitcell object can be accessed</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unitcell</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;no unitcell given&#39;</span><span class="p">)</span>

        <span class="c"># make sure all given entities exist within the unitcell</span>
        <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="n">ents</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">ent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ents</span><span class="p">(),</span> \
                <span class="s">&#39;entity </span><span class="si">%s</span><span class="s"> does not exist in the unitcell&#39;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="n">ent</span><span class="p">)</span>

        <span class="c"># handle multiple entities</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ents</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;at least two entities have to be given&#39;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ents</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ent1</span><span class="p">,</span> <span class="n">ent2</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">ents</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">ent1</span><span class="p">,</span> <span class="n">ent2</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ent1</span><span class="p">,</span> <span class="n">ent2</span> <span class="o">=</span> <span class="n">ents</span>

            <span class="c"># get keyword arguments</span>
            <span class="n">hop</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;hop&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">)</span>
            <span class="n">iso</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;iso&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;there are unknown keyword arguments&#39;</span>

            <span class="c"># just delete if zero is given</span>
            <span class="k">if</span> <span class="n">hop</span> <span class="o">==</span> <span class="mf">0.</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ent1</span><span class="p">,</span> <span class="n">ent2</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hops</span><span class="p">:</span>
                <span class="k">del</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hops</span><span class="p">[</span><span class="n">ent1</span><span class="p">,</span> <span class="n">ent2</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">hops</span><span class="p">[</span><span class="n">ent1</span><span class="p">,</span> <span class="n">ent2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalmath</span><span class="p">(</span><span class="n">hop</span><span class="p">)</span>

            <span class="c"># isotropic hopping?</span>
            <span class="k">if</span> <span class="n">iso</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">ent2</span><span class="p">,</span> <span class="n">ent1</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">,</span> <span class="n">iso</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Neighbor.add_vect"><a class="viewcode-back" href="../../sc.html#tb.sc.Neighbor.add_vect">[docs]</a>    <span class="k">def</span> <span class="nf">add_vect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vect</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">iso</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">perm</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">permall</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a vector to this neighbor interaction object, leading to a</span>
<span class="sd">        specific neighbor cell.</span>

<span class="sd">        If iso is set to True, also the neighbor of the negative vector is set,</span>
<span class="sd">        with the adjoint (complex conjugated and transposed) of the hopping</span>
<span class="sd">        matrix of this neighbor.</span>

<span class="sd">        If perm is set to True, the neighbors of all permutations of the given</span>
<span class="sd">        vector are set with the same neighbor hopping matrix. Of course, if</span>
<span class="sd">        both iso and perm are set to True, the neighbors of the negative</span>
<span class="sd">        vectors of all permutations are set with the adjoint of the matrix.</span>
<span class="sd">        This case could be useful for bcc-like structures.</span>

<span class="sd">        If permall is set to True, the blocks of all permutations of the given</span>
<span class="sd">        vector are set with the neighbor&#39;s hopping matrix, including all</span>
<span class="sd">        negative values, i.e. covering all possible directions. Not the</span>
<span class="sd">        adjoint, but the matrix itself is always used. USE THIS OPTION WITH</span>
<span class="sd">        CAUTION! It should only be used in systems with only one site per</span>
<span class="sd">        unitcell. Otherwise, unwanted hoppings will probably occur. This option</span>
<span class="sd">        overrides the options iso and perm.&quot;&quot;&quot;</span>
        <span class="c"># 2011-08-20</span>
        <span class="c"># former tb.Lattice.add_vect</span>

        <span class="c"># vector</span>
        <span class="k">if</span> <span class="n">vect</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">vect</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span><span class="o">+</span><span class="p">(</span><span class="mi">0</span><span class="p">,)</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c"># add this vector to the list of vectors of this neighbor interaction</span>
        <span class="c"># Respect automatic symmetry features (permutations and isotropy)</span>
        <span class="k">if</span> <span class="n">permall</span><span class="p">:</span>
            <span class="c"># add all permutations of the given vector (including all possible</span>
            <span class="c"># sign changes of the elements)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vects</span> <span class="o">+=</span> <span class="n">shells</span><span class="o">.</span><span class="n">signperms</span><span class="p">(</span><span class="n">vect</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">perm</span><span class="p">:</span>
                <span class="c"># add all permutations of the given vector (without sign</span>
                <span class="c"># changes)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vects</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">permutations</span><span class="p">(</span><span class="n">vect</span><span class="p">)))</span>
                <span class="k">if</span> <span class="n">iso</span><span class="p">:</span>
                    <span class="c"># also add all permutations of the negative vector</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">isovects</span> <span class="o">+=</span> \
                        <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">permutations</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span>
                            <span class="o">-</span><span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vect</span><span class="p">)))))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># just add this vector</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vects</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vect</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">iso</span><span class="p">:</span>
                    <span class="c"># also add the negative vector</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">isovects</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="o">-</span><span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vect</span><span class="p">)))</span>
</div>
<div class="viewcode-block" id="Neighbor.tbmat"><a class="viewcode-back" href="../../sc.html#tb.sc.Neighbor.tbmat">[docs]</a>    <span class="k">def</span> <span class="nf">tbmat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return submatrix of this neighbor interaction object, containing all</span>
<span class="sd">        constant hopping parameters. Convert to the specified format (one of</span>
<span class="sd">        dense, csr, csc, dok, coo, dia, bsr, or lil).&quot;&quot;&quot;</span>
        <span class="c"># 2012-05-01</span>
        <span class="c"># based on tb.sc.Neighbor.tbmat from 2011-08-20 - 2012-03-02</span>

        <span class="c"># assure that a reference to the unitcell object and the position list</span>
        <span class="c"># are available</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unitcell</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s">&#39;no unitcell given&#39;</span><span class="p">)</span>

        <span class="c"># initialize data structures</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">lil_matrix</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ents</span><span class="p">())),)</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span>
                                      <span class="n">dtype</span><span class="o">=</span><span class="p">(</span><span class="nb">complex</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_complex</span><span class="p">()</span>
                                             <span class="k">else</span> <span class="nb">float</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c"># get index of each entity</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">ent</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ents</span><span class="p">()):</span>
            <span class="n">inds</span><span class="p">[</span><span class="n">ent</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind</span>

        <span class="c"># fill all matrix elements</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">ent1</span><span class="p">,</span> <span class="n">ent2</span><span class="p">),</span> <span class="n">hop</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hops</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">hop</span><span class="p">,</span> <span class="s">&#39;__call__&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">random</span><span class="p">[</span><span class="n">ent1</span><span class="p">,</span> <span class="n">ent2</span><span class="p">]</span> <span class="o">=</span> <span class="n">hop</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mat</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">ent1</span><span class="p">],</span> <span class="n">inds</span><span class="p">[</span><span class="n">ent2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">hop</span>

        <span class="c"># return the matrix</span>
        <span class="k">return</span> <span class="n">mat</span><span class="o">.</span><span class="n">asformat</span><span class="p">(</span><span class="n">format</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Neighbor.is_complex"><a class="viewcode-back" href="../../sc.html#tb.sc.Neighbor.is_complex">[docs]</a>    <span class="k">def</span> <span class="nf">is_complex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check whether this neighbor object contains complex potentials or</span>
<span class="sd">        hoppings.&quot;&quot;&quot;</span>
        <span class="c"># 2011-08-20 - 2012-08-01</span>
        <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ents</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">ent</span><span class="o">.</span><span class="n">is_complex</span><span class="p">():</span>
                <span class="k">return</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">hop</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hops</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">hop</span><span class="p">,</span> <span class="s">&#39;__call__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">hop</span><span class="o">.</span><span class="n">is_complex</span><span class="p">():</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="k">elif</span> <span class="n">scipy</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">hop</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>
</div>
<div class="viewcode-block" id="Neighbor.checkhops"><a class="viewcode-back" href="../../sc.html#tb.sc.Neighbor.checkhops">[docs]</a>    <span class="k">def</span> <span class="nf">checkhops</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if all the entities of the defined hoppings exist in the</span>
<span class="sd">        unitcell.&quot;&quot;&quot;</span>
        <span class="c"># 2011-08-22</span>

        <span class="c"># check if a unitcell definition is given</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unitcell</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;no unitcell given&#39;</span><span class="p">)</span>

        <span class="c"># cycle all defined hoppings and perform the check</span>
        <span class="k">for</span> <span class="n">ent1</span><span class="p">,</span> <span class="n">ent2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hops</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ent1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">ents</span><span class="p">():</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="k">if</span> <span class="n">ent2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">ents</span><span class="p">():</span>
                <span class="k">return</span> <span class="bp">False</span>

        <span class="c"># otherwise, return positive check result</span>
        <span class="k">return</span> <span class="bp">True</span>

</div></div>
<div class="viewcode-block" id="Site"><a class="viewcode-back" href="../../sc.html#tb.sc.Site">[docs]</a><span class="k">class</span> <span class="nc">Site</span><span class="p">(</span><span class="n">SuperCellObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Define a site. May be part of the unitcell of a lattice, or a single</span>
<span class="sd">    site within the supercell. May contain several entities (potentials).&quot;&quot;&quot;</span>
    <span class="c"># 2011-08-19 - 2012-03-02</span>

    <span class="c"># initialize instance counter</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">coord</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ents</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">hops</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize site.&quot;&quot;&quot;</span>
        <span class="c"># 2011-08-19 - 2012-03-02</span>

        <span class="c"># number of dimensions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalmath</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;number of dimensions must be positive integer&#39;</span>

        <span class="c"># coordinates</span>
        <span class="k">if</span> <span class="n">coord</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coord</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coord</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.</span><span class="p">,)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span>

        <span class="c"># data structures</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ents</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">ents</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">ents</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hops</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">hops</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">hops</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c"># set label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%s%i</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ucletters</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">),</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">label</span>

<div class="viewcode-block" id="Site.add_ent"><a class="viewcode-back" href="../../sc.html#tb.sc.Site.add_ent">[docs]</a>    <span class="k">def</span> <span class="nf">add_ent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">ents</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add an entity to the site. The entity is characterized by a constant</span>
<span class="sd">        or random potential (pot).</span>

<span class="sd">        Also, predefined site objects may be given as positional arguments.</span>
<span class="sd">        Then, no keyword arguments may be given.&quot;&quot;&quot;</span>
        <span class="c"># 2011-08-19 - 2012-05-01</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ents</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ent</span> <span class="o">=</span> <span class="n">Entity</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ent</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ent</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s">&#39;no keyword arguments allowed if positional &#39;</span> <span class="o">+</span>
                               <span class="s">&#39;arguments are given&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="n">ents</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ent</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ents</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ent</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Site.add_hop"><a class="viewcode-back" href="../../sc.html#tb.sc.Site.add_hop">[docs]</a>    <span class="k">def</span> <span class="nf">add_hop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">ents</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a hopping between the given entities. All entities must already</span>
<span class="sd">        exist in the list of entities of this site. The hopping parameter can</span>
<span class="sd">        either be constant or drawn from a probability distribution. The</span>
<span class="sd">        interaction may be defined as isotropic (iso), meaning that also</span>
<span class="sd">        hopping in the opposite direction will be allowed.&quot;&quot;&quot;</span>
        <span class="c"># 2011-08-19 - 2011-11-09</span>

        <span class="c"># make sure all entities exist at this site</span>
        <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="n">ents</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">ent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ents</span><span class="p">,</span> \
                <span class="s">&#39;Entity </span><span class="si">%s</span><span class="s"> does not exist at this site&#39;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="n">ent</span><span class="p">)</span>

        <span class="c"># handle multiple entities</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ents</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;at least two entities have to be given&#39;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ents</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ent1</span><span class="p">,</span> <span class="n">ent2</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">ents</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">ent1</span><span class="p">,</span> <span class="n">ent2</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ent1</span><span class="p">,</span> <span class="n">ent2</span> <span class="o">=</span> <span class="n">ents</span>

            <span class="c"># get keyword arguments</span>
            <span class="n">hop</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;hop&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">)</span>
            <span class="c">#dist = kwargs.get(&#39;dist&#39;, None)</span>
            <span class="c">#loc = kwargs.get(&#39;loc&#39;, 0.)</span>
            <span class="c">#scale = kwargs.get(&#39;scale&#39;, 1.)</span>
            <span class="n">iso</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;iso&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>

            <span class="c"># check if the two entities are identical</span>
            <span class="k">if</span> <span class="n">ent1</span> <span class="o">==</span> <span class="n">ent2</span><span class="p">:</span>
                <span class="c"># then just redefine the potential of that entity</span>
                <span class="n">ent1</span><span class="o">.</span><span class="n">pot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalmath</span><span class="p">(</span><span class="n">hop</span><span class="p">)</span>
                <span class="k">return</span>

            <span class="c"># just delete entry if zero was given</span>
            <span class="k">if</span> <span class="n">hop</span> <span class="o">==</span> <span class="mf">0.</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ent1</span><span class="p">,</span> <span class="n">ent2</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hops</span><span class="p">:</span>
                <span class="k">del</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hops</span><span class="p">[</span><span class="n">ent1</span><span class="p">,</span> <span class="n">ent2</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">hops</span><span class="p">[</span><span class="n">ent1</span><span class="p">,</span> <span class="n">ent2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalmath</span><span class="p">(</span><span class="n">hop</span><span class="p">)</span>

            <span class="c"># isotropic hopping?</span>
            <span class="k">if</span> <span class="n">iso</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_hop</span><span class="p">(</span><span class="n">ent2</span><span class="p">,</span> <span class="n">ent1</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(),</span> <span class="n">iso</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                <span class="c">### What will happen if hop is random and iso is True?</span>
</div>
<div class="viewcode-block" id="Site.tbmat"><a class="viewcode-back" href="../../sc.html#tb.sc.Site.tbmat">[docs]</a>    <span class="k">def</span> <span class="nf">tbmat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return submatrix of this site, containing all constant hoppings and</span>
<span class="sd">        potentials. Convert to the specified format (one of dense, csr, csc,</span>
<span class="sd">        dok, coo, dia, bsr, or lil).  If new is True, recalculate the whole</span>
<span class="sd">        matrix, including the random hopping dictionary. If cache is True,</span>
<span class="sd">        always return the cached version of the matrix (if there is no cached</span>
<span class="sd">        version, raise an exception). If new and cache are False, calculate the</span>
<span class="sd">        submatrix only if there is no cached version, otherwise just return the</span>
<span class="sd">        cache.&quot;&quot;&quot;</span>
        <span class="c"># 2011-08-19 - 2012-08-04</span>

        <span class="c"># initialize data structures</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">lil_matrix</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ents</span><span class="p">),)</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span>
                                      <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">infertype</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c"># get index of each entity</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">ent</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ents</span><span class="p">):</span>
            <span class="n">inds</span><span class="p">[</span><span class="n">ent</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind</span>

        <span class="c"># fill the diagonal entries with the potentials of the entities</span>
        <span class="n">pots</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ents</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ent</span><span class="o">.</span><span class="n">pot</span><span class="p">,</span> <span class="s">&#39;__call__&#39;</span><span class="p">):</span>
                <span class="n">pots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">random</span><span class="p">[</span><span class="n">ent</span><span class="p">,</span> <span class="n">ent</span><span class="p">]</span> <span class="o">=</span> <span class="n">ent</span><span class="o">.</span><span class="n">pot</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ent</span><span class="o">.</span><span class="n">pot</span><span class="p">)</span>
        <span class="n">mat</span><span class="o">.</span><span class="n">setdiag</span><span class="p">(</span><span class="n">pots</span><span class="p">)</span>

        <span class="c"># fill off-diagonal entries with hoppings</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">ent1</span><span class="p">,</span> <span class="n">ent2</span><span class="p">),</span> <span class="n">hop</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hops</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">hop</span><span class="p">,</span> <span class="s">&#39;__call__&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">random</span><span class="p">[</span><span class="n">ent1</span><span class="p">,</span> <span class="n">ent2</span><span class="p">]</span> <span class="o">=</span> <span class="n">hop</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mat</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">ent1</span><span class="p">],</span> <span class="n">inds</span><span class="p">[</span><span class="n">ent2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">hop</span>

        <span class="c"># return the matrix</span>
        <span class="k">return</span> <span class="n">mat</span><span class="o">.</span><span class="n">asformat</span><span class="p">(</span><span class="n">format</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Site.is_complex"><a class="viewcode-back" href="../../sc.html#tb.sc.Site.is_complex">[docs]</a>    <span class="k">def</span> <span class="nf">is_complex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check whether this site has complex potentials or hoppings.&quot;&quot;&quot;</span>
        <span class="c"># 2011-08-19 - 2012-08-01</span>
        <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ents</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ent</span><span class="o">.</span><span class="n">is_complex</span><span class="p">():</span>
                <span class="k">return</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">hop</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hops</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">hop</span><span class="p">,</span> <span class="s">&#39;__call__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">hop</span><span class="o">.</span><span class="n">is_complex</span><span class="p">():</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="k">elif</span> <span class="n">scipy</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">hop</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>
</div>
<div class="viewcode-block" id="Site.checkhops"><a class="viewcode-back" href="../../sc.html#tb.sc.Site.checkhops">[docs]</a>    <span class="k">def</span> <span class="nf">checkhops</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unitcell</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if all the entities of the hoppings exist in the list of</span>
<span class="sd">        entities. If a unitcell object is given, also checks if all the hopping</span>
<span class="sd">        entities exist in that unitcell.&quot;&quot;&quot;</span>
        <span class="c"># 2011-08-22</span>

        <span class="k">for</span> <span class="n">ent1</span><span class="p">,</span> <span class="n">ent2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hops</span><span class="p">:</span>
            <span class="c"># Always check the entities of this site</span>
            <span class="k">if</span> <span class="n">ent1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ents</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="k">if</span> <span class="n">ent2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ents</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>

            <span class="c"># if a unitcell was given, check all the entities of all the sites</span>
            <span class="c"># of that unitcell, too</span>
            <span class="k">if</span> <span class="n">unitcell</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ent1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unitcell</span><span class="o">.</span><span class="n">ents</span><span class="p">():</span>
                    <span class="k">return</span> <span class="bp">False</span>
                <span class="k">if</span> <span class="n">ent2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unitcell</span><span class="o">.</span><span class="n">ents</span><span class="p">():</span>
                    <span class="k">return</span> <span class="bp">False</span>

        <span class="c"># otherwise, return positive check result</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="Site.get_ent"><a class="viewcode-back" href="../../sc.html#tb.sc.Site.get_ent">[docs]</a>    <span class="k">def</span> <span class="nf">get_ent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get entity by label.&quot;&quot;&quot;</span>
        <span class="c"># 2011-12-18</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ents</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ent</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="n">label</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">ent</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s">&#39;entity with label </span><span class="si">%s</span><span class="s"> not found&#39;</span> <span class="o">%</span> <span class="n">label</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

</div></div>
<div class="viewcode-block" id="Entity"><a class="viewcode-back" href="../../sc.html#tb.sc.Entity">[docs]</a><span class="k">class</span> <span class="nc">Entity</span><span class="p">(</span><span class="n">SuperCellObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Define an entity, characterized by a constant or random potential</span>
<span class="sd">    (pot).&quot;&quot;&quot;</span>
    <span class="c"># 2011-08-19 - 2011-11-09</span>

    <span class="c"># initialize instance counter</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pot</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize entity.&quot;&quot;&quot;</span>
        <span class="c"># 2011-08-19 - 2011-11-09</span>

        <span class="c"># initialize data structures</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalmath</span><span class="p">(</span><span class="n">pot</span><span class="p">)</span>

        <span class="c"># set label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%s%i</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ucletters</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">),</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">label</span>

<div class="viewcode-block" id="Entity.is_complex"><a class="viewcode-back" href="../../sc.html#tb.sc.Entity.is_complex">[docs]</a>    <span class="k">def</span> <span class="nf">is_complex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check whether this entity has a complex potential.&quot;&quot;&quot;</span>
        <span class="c"># 2011-08-19 - 2012-08-01</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pot</span><span class="p">,</span> <span class="s">&#39;__call__&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pot</span><span class="o">.</span><span class="n">is_complex</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pot</span><span class="p">)</span>

</div></div>
<span class="n">_dist</span> <span class="o">=</span> <span class="n">dist</span>  <span class="c"># &quot;dist&quot; is already defined inside the function</span>
<span class="nd">@Frog</span><span class="p">(</span><span class="n">inmap</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="s">&#39;$0/param&#39;</span><span class="p">,</span> <span class="n">pot</span><span class="o">=</span><span class="s">&#39;$0/param&#39;</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="s">&#39;$0/param&#39;</span><span class="p">,</span>
                 <span class="n">dist</span><span class="o">=</span><span class="s">&#39;$0/param&#39;</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s">&#39;$0/param&#39;</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="s">&#39;$0/param&#39;</span><span class="p">),</span>
      <span class="n">preproc</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">pot</span><span class="o">=</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">pot</span><span class="p">,</span>
                   <span class="n">hop</span><span class="o">=</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">hop</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">dist</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span>
                   <span class="n">loc</span><span class="o">=</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">scale</span><span class="p">),</span>
      <span class="n">outmap</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="bp">None</span><span class="p">},</span>  <span class="c"># {0: &#39;$0/mat&#39;},</span>
      <span class="n">wrapname</span><span class="o">=</span><span class="s">&#39;_scnnmatf&#39;</span><span class="p">)</span>
<span class="nd">@Frog</span><span class="p">(</span><span class="n">preproc</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;,&#39;</span><span class="p">)]))</span>
<div class="viewcode-block" id="scnnmat"><a class="viewcode-back" href="../../sc.html#tb.sc.scnnmat">[docs]</a><span class="k">def</span> <span class="nf">scnnmat</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">pot</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">hop</span><span class="o">=-</span><span class="mf">1.</span><span class="p">,</span> <span class="n">bcond</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span>
            <span class="n">format</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return tight binding matrix of a 1-band simple cubic lattice with</span>
<span class="sd">    constant isotropic next-neighbor hopping (hop) and either constant</span>
<span class="sd">    potentials (pot) or random potentials, drawn from a certain probability</span>
<span class="sd">    distribution (dist) defined by certain parameters (loc, scale). The</span>
<span class="sd">    boundary conditions (bcond) can chosen to be static (s), periodic (p) or</span>
<span class="sd">    antiperiodic (a) and can be set differently for each dimension. The length</span>
<span class="sd">    of the tuple that is specifying the system dimensions (shape) is also</span>
<span class="sd">    defining the dimensionality of the system.</span>

<span class="sd">    Because of the restriction to this special case, this function reaches an</span>
<span class="sd">    optimum of efficiency. The matrix is returned in a sparse matrix format</span>
<span class="sd">    (format).&quot;&quot;&quot;</span>
    <span class="c"># 2011-09-06 - 2014-01-26</span>
    <span class="c"># based on former tb.scnnmat from 2011-02-28 to 2011-06-20</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">shape</span><span class="p">,)</span>

    <span class="n">size</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

    <span class="c"># edit boundary conditions</span>
    <span class="k">if</span> <span class="n">bcond</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">bcond</span> <span class="o">=</span> <span class="s">&#39;p&#39;</span>
    <span class="c">#bcond = bcond[:dim]</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">bcond</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">dim</span><span class="p">:</span>
        <span class="n">bcond</span> <span class="o">+=</span> <span class="n">bcond</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c"># general idea:</span>
    <span class="c"># 1. Build the matrix of dims[:-1] recursevely, set the dims[-1] blocks</span>
    <span class="c">#    with it.</span>
    <span class="c"># 2. Build the matrix of dims[-1], set streched slices dims[:-1] times.</span>
    <span class="c">### This description sucks!</span>

    <span class="c"># step 1</span>
    <span class="n">subshape</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">subsize</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">subshape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="c"># initialize matrix</span>
    <span class="k">if</span> <span class="n">subsize</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c"># Get submatrix recursevely and set the diagonal blocks with it</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],))),</span>
                                <span class="n">scnnmat</span><span class="p">(</span><span class="n">subshape</span><span class="p">,</span>
                                        <span class="n">hop</span><span class="o">=</span><span class="n">hop</span><span class="p">,</span> <span class="n">bcond</span><span class="o">=</span><span class="n">bcond</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">tolil</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># Initialize a new empty matrix</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">lil_matrix</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">size</span><span class="p">,))</span>

    <span class="c"># step 2a</span>
    <span class="c"># if (anti)periodic boundary conditions are given, set respective elements</span>
    <span class="c"># as well. Do this first, because they may be overwritten by the direct</span>
    <span class="c"># hoppings in the next step</span>
    <span class="k">if</span> <span class="n">bcond</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="s">&#39;pa&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">bcond</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;p&#39;</span><span class="p">:</span>
            <span class="n">bcondhoparray</span> <span class="o">=</span> <span class="n">hop</span><span class="o">*</span><span class="n">scipy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">subsize</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># sign-flip values in the case of antiperiodic boundary conditions</span>
            <span class="n">bcondhoparray</span> <span class="o">=</span> <span class="o">-</span><span class="n">hop</span><span class="o">*</span><span class="n">scipy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">subsize</span><span class="p">))</span>

        <span class="c"># set complete diagonals at once</span>
        <span class="n">mat</span><span class="o">.</span><span class="n">setdiag</span><span class="p">(</span><span class="n">bcondhoparray</span><span class="p">,</span> <span class="n">size</span><span class="o">-</span><span class="n">subsize</span><span class="p">)</span>
        <span class="n">mat</span><span class="o">.</span><span class="n">setdiag</span><span class="p">(</span><span class="n">bcondhoparray</span><span class="p">,</span> <span class="n">subsize</span><span class="o">-</span><span class="n">size</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">bcond</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;s&#39;</span><span class="p">:</span>
        <span class="c"># Do not set anything, but neither show an error message...</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;bad boundary condition: </span><span class="si">%s</span><span class="s">. &#39;</span> <span class="o">%</span> <span class="n">bcond</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
                         <span class="s">&#39;Possible values: s (static), p (periodic), a &#39;</span> <span class="o">+</span>
                         <span class="s">&#39;(antiperiodic)&#39;</span><span class="p">)</span>

    <span class="c"># step 2b</span>
    <span class="c"># set off-diagonal elements with direct hoppings</span>
    <span class="n">hoparray</span> <span class="o">=</span> <span class="n">hop</span><span class="o">*</span><span class="n">scipy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">size</span><span class="o">-</span><span class="n">subsize</span><span class="p">))</span>
    <span class="n">mat</span><span class="o">.</span><span class="n">setdiag</span><span class="p">(</span><span class="n">hoparray</span><span class="p">,</span> <span class="n">subsize</span><span class="p">)</span>
    <span class="n">mat</span><span class="o">.</span><span class="n">setdiag</span><span class="p">(</span><span class="n">hoparray</span><span class="p">,</span> <span class="o">-</span><span class="n">subsize</span><span class="p">)</span>

    <span class="c"># step 2c</span>
    <span class="c"># set diagonal elements with potential</span>
    <span class="k">if</span> <span class="n">dist</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">pot</span> <span class="o">!=</span> <span class="mf">0.</span><span class="p">:</span>  <span class="c"># spare this step if potentials are zero</span>
            <span class="n">mat</span><span class="o">.</span><span class="n">setdiag</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">size</span><span class="p">))</span><span class="o">*</span><span class="n">pot</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">_dist</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
        <span class="n">get_random_values</span> <span class="o">=</span> <span class="n">d</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
        <span class="n">mat</span><span class="o">.</span><span class="n">setdiag</span><span class="p">(</span><span class="n">get_random_values</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">))</span>

    <span class="c"># return matrix</span>
    <span class="k">return</span> <span class="n">mat</span><span class="o">.</span><span class="n">asformat</span><span class="p">(</span><span class="n">format</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="SparseLattice"><a class="viewcode-back" href="../../sc.html#tb.sc.SparseLattice">[docs]</a><span class="k">class</span> <span class="nc">SparseLattice</span><span class="p">(</span><span class="n">LatticeObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Define a sparse lattice, using a unitcell that may contain multiple</span>
<span class="sd">    sites, but in contrast to a regular lattice, is not repeated periodically</span>
<span class="sd">    in space, but exists only at given positions within the lattice grid.</span>

<span class="sd">    Allow &quot;long&quot; hoppings if &quot;longhops&quot; is set to True. &quot;Long&quot; hoppings are</span>
<span class="sd">    those that circle the whole lattice in at least one dimension due to</span>
<span class="sd">    periodic boundary conditions (dangerous, because hoppings from a site to</span>
<span class="sd">    itself could be possible).&quot;&quot;&quot;</span>
    <span class="c"># 2012-04-27 - 2012-09-06</span>
    <span class="c"># based on tb.sc.Lattice from 2011-08-11 - 2012-04-05</span>
    <span class="c"># former tb.Lattice from 2011-03-05 - 2011-03-31</span>

    <span class="c"># initialize instance counter</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">bcond</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">bvects</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">label</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">neighs</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">positions</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">longhops</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">diaghops</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize sparse lattice object.&quot;&quot;&quot;</span>
        <span class="c"># 2012-04-27 - 2012-09-06</span>
        <span class="c"># based on tb.sc.Lattice.__init__ from 2011-08-11 - 2012-03-02</span>

        <span class="c"># number of dimensions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalmath</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;number of dimensions must be positive integer&#39;</span>

        <span class="c"># shape</span>
        <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;shape must consist of positive integers&#39;</span>

        <span class="c"># boundary conditions</span>
        <span class="k">if</span> <span class="n">bcond</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bcond</span> <span class="o">=</span> <span class="s">&#39;p&#39;</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bcond</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">bcond</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">bcond</span> <span class="o">!=</span> <span class="s">&#39;&#39;</span><span class="p">,</span> <span class="s">&#39;no boundary conditions given&#39;</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bcond</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bcond</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bcond</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c"># origin</span>
        <span class="k">if</span> <span class="n">origin</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.</span><span class="p">,)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">origin</span><span class="p">)</span>

        <span class="c"># basis vectors that span the lattice within the real space of the</span>
        <span class="c"># supercell</span>
        <span class="k">if</span> <span class="n">bvects</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bvects</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bvects</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bvects</span><span class="p">)</span>

        <span class="c"># list of inter-cell hoppings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">neighs</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">neighs</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">neighs</span>

        <span class="c"># create unitcell</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unitcell</span> <span class="o">=</span> <span class="n">UnitCell</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">uc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unitcell</span>  <span class="c"># shortcut</span>

        <span class="c"># set label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%s%i</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ucletters</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">),</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">label</span>

        <span class="c"># initialize list of positions where the unitcell exists</span>
        <span class="c"># can also be set with a PosRule instance, to choose random positions</span>
        <span class="c"># following a certain rule</span>
        <span class="k">if</span> <span class="n">positions</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">positions</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">pos</span><span class="o">.</span><span class="n">PosRule</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">positions</span> <span class="o">=</span> <span class="n">positions</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">positions</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>

        <span class="c"># initialize switches</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">longhops</span> <span class="o">=</span> <span class="n">longhops</span>  <span class="c"># allow long hoppings circling the lattice</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">diaghops</span> <span class="o">=</span> <span class="n">diaghops</span>  <span class="c"># put real part of negative hoppings on</span>
                                  <span class="c"># diagonal</span>

<div class="viewcode-block" id="SparseLattice.size"><a class="viewcode-back" href="../../sc.html#tb.sc.SparseLattice.size">[docs]</a>    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return number of cells.&quot;&quot;&quot;</span>
        <span class="c"># 2012-04-27</span>
        <span class="c"># based on tb.sc.Lattice.size from 2011-08-21 - 2011-10-12</span>
        <span class="c">#return scipy.prod(self.shape)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span> <span class="s">&#39;__call__&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="o">.</span><span class="n">num</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="SparseLattice.indmat"><a class="viewcode-back" href="../../sc.html#tb.sc.SparseLattice.indmat">[docs]</a>    <span class="k">def</span> <span class="nf">indmat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vects</span><span class="p">,</span> <span class="n">positions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return index matrix. Format will be coordinate sparse format (coo).</span>
<span class="sd">        It will contain ones for those blocks that have to be set to enable</span>
<span class="sd">        hopping in the direction of the given vector (vect), and zeros</span>
<span class="sd">        elsewhere (and minus one where a sign flip should occur due to</span>
<span class="sd">        antiperiodic boundary conditions).&quot;&quot;&quot;</span>
        <span class="c"># 2012-04-27 - 2012-05-06</span>
        <span class="c"># based on tb.sc.Lattice.indmat from 2011-08-25</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>

        <span class="c"># initialize lists that hold the indices of the blocks where the</span>
        <span class="c"># submatrix of this neighbor interaction will be put</span>
        <span class="n">rowind</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">colind</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">signchanges</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c"># determine the indices of the blocks where to put the hopping matrix</span>
        <span class="c"># of the neighbor interaction object</span>
        <span class="k">for</span> <span class="n">vect</span> <span class="ow">in</span> <span class="n">vects</span><span class="p">:</span>
            <span class="c"># exclude &quot;long&quot; hopping vectors</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">longhops</span><span class="p">:</span>
                <span class="n">toolong</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
                    <span class="c"># is this vector element greater or equal than the lattice</span>
                    <span class="c"># in this dimension?</span>
                    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">vect</span><span class="p">[</span><span class="n">d</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">d</span><span class="p">]:</span>
                        <span class="n">toolong</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">if</span> <span class="n">toolong</span><span class="p">:</span>
                    <span class="k">continue</span>

            <span class="c"># get coordinates shifted by the current vector</span>
            <span class="n">shifted</span> <span class="o">=</span> <span class="n">positions</span><span class="o">+</span><span class="n">vect</span>

            <span class="c"># determine number of sign changes (if antiperiodic boundary</span>
            <span class="c"># conditions are used)</span>
            <span class="n">cdiv</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">shifted</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

            <span class="c"># wrap around the shifted coordinates so that they do not lie</span>
            <span class="c"># outside the lattice</span>
            <span class="n">shifted</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">shifted</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

            <span class="c"># calculate which indices the shifted coordinates would have in the</span>
            <span class="c"># normal coordinates list</span>
            <span class="n">newrowinds</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">newcolinds</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">findinds</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">shifted</span><span class="p">)</span>

            <span class="c"># delete those entries whose shifted indices do not appear (where</span>
            <span class="c"># newcolinds has value -1)</span>
            <span class="n">select</span> <span class="o">=</span> <span class="n">newcolinds</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="c">#print &#39;select&#39;, select, len(select) # error for shape=10,10,10???</span>
            <span class="c">#print &#39;newrowinds&#39;, newrowinds, len(newrowinds)</span>
            <span class="c">#print &#39;newcolinds&#39;, newcolinds, len(newcolinds)</span>
            <span class="c">#print &#39;positions&#39;, positions, len(positions)</span>
            <span class="c">#print &#39;size&#39;, self.size()</span>
            <span class="n">newrowinds</span> <span class="o">=</span> <span class="n">newrowinds</span><span class="p">[</span><span class="n">select</span><span class="p">]</span>
            <span class="n">newcolinds</span> <span class="o">=</span> <span class="n">newcolinds</span><span class="p">[</span><span class="n">select</span><span class="p">]</span>

            <span class="c"># respect boundary conditions</span>
            <span class="n">donotuse</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">newcolinds</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">nosc</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">newcolinds</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>  <span class="c"># number of sign</span>
                                                            <span class="c"># changes</span>
            <span class="k">for</span> <span class="n">dind</span><span class="p">,</span> <span class="n">bc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bcond</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">bc</span> <span class="o">==</span> <span class="s">&#39;s&#39;</span><span class="p">:</span>
                    <span class="c"># if a dimension has static boundary conditions and cdiv is</span>
                    <span class="c"># not zero, do not set those blocks</span>
                    <span class="n">donotuse</span> <span class="o">+=</span> <span class="n">cdiv</span><span class="p">[:,</span> <span class="n">dind</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span>
                <span class="k">elif</span> <span class="n">bc</span> <span class="o">==</span> <span class="s">&#39;a&#39;</span><span class="p">:</span>
                    <span class="c"># for every dimension with antiperiodic boundary</span>
                    <span class="c"># conditions, change the sign of the blocks a certain</span>
                    <span class="c"># number of times according to cdiv</span>
                    <span class="n">nosc</span> <span class="o">+=</span> <span class="n">cdiv</span><span class="p">[:,</span> <span class="n">dind</span><span class="p">]</span>

            <span class="c"># append the indices and sign changes to the big index lists</span>
            <span class="n">rowind</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">newrowinds</span><span class="p">[</span><span class="n">donotuse</span> <span class="o">==</span> <span class="bp">False</span><span class="p">])</span>  <span class="c"># &quot;is False&quot; does</span>
            <span class="n">colind</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">newcolinds</span><span class="p">[</span><span class="n">donotuse</span> <span class="o">==</span> <span class="bp">False</span><span class="p">])</span>  <span class="c"># not work</span>
            <span class="n">signchanges</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nosc</span><span class="p">[</span><span class="n">donotuse</span> <span class="o">==</span> <span class="bp">False</span><span class="p">])</span>

        <span class="c"># debugging checks</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">rowind</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">colind</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">rowind</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">signchanges</span><span class="p">)</span>

        <span class="c"># construct index matrix. It defines where and with which sign the</span>
        <span class="c"># hopping submatrix of this neighbor interaction will go.</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">(((</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">signchanges</span><span class="p">),</span>
                                        <span class="p">(</span><span class="n">rowind</span><span class="p">,</span> <span class="n">colind</span><span class="p">)),</span>
                                       <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">(),)</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="SparseLattice.coords"><a class="viewcode-back" href="../../sc.html#tb.sc.SparseLattice.coords">[docs]</a>    <span class="k">def</span> <span class="nf">coords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the coordinates of all the sites.&quot;&quot;&quot;</span>
        <span class="c"># 2012-05-01</span>
        <span class="c"># based on tb.sc.Lattice from 2012-04-05</span>
        <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">sites</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span>
                <span class="c">#yield tuple(self.origin+scipy.dot(self.bvects, site.coord))</span>
</div>
<div class="viewcode-block" id="SparseLattice.tbmat"><a class="viewcode-back" href="../../sc.html#tb.sc.SparseLattice.tbmat">[docs]</a>    <span class="k">def</span> <span class="nf">tbmat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">distinguish</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return tight binding matrix of this sparse lattice, convert to the</span>
<span class="sd">        specified format (one of dense, csr, csc, dok, coo, dia, bsr, or lil).</span>

<span class="sd">        If distinguish is True, also return a tuple of index lists, specifying</span>
<span class="sd">        how the positions can be distinguished.&quot;&quot;&quot;</span>
        <span class="c"># 2012-05-06 - 2012-09-03</span>
        <span class="c"># based on tb.sc.Lattice.tbmat from 2011-08-20 - 2012-03-02</span>

        <span class="c"># get all cell positions, sort them to have a fixed order</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span> <span class="s">&#39;__call__&#39;</span><span class="p">):</span>
            <span class="c"># generate new realization of disorder</span>
            <span class="k">if</span> <span class="n">distinguish</span><span class="p">:</span>
                <span class="c"># also return indices of impurities inside/outside the spheres</span>
                <span class="n">position_classes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">(</span><span class="n">distinguish</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="n">positions</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">position_classes</span><span class="p">)))</span>
                <span class="n">positions</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

                <span class="c"># convert positions to indices</span>
                <span class="c">#print position_classes, len(position_classes)</span>
                <span class="n">position_classes_ind</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">position_class</span> <span class="ow">in</span> <span class="n">position_classes</span><span class="p">:</span>
                    <span class="c">#position_classes_ind.append(</span>
                        <span class="c">#list(self.ndindex2index(position_class)))</span>
                    <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">position_class</span><span class="p">:</span>
                        <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">positions</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
                    <span class="n">position_classes_ind</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">positions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># use the given fixed list of positions</span>
            <span class="k">if</span> <span class="n">distinguish</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;cannot distinguish different classes of &#39;</span> <span class="o">+</span>
                                 <span class="s">&#39;positions if they are provided directly&#39;</span><span class="p">)</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">)</span>
        <span class="n">positions</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">positions_cache</span> <span class="o">=</span> <span class="n">positions</span>  <span class="c"># remember positions for checks</span>

        <span class="c"># get index of each entity</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">ent</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">ents</span><span class="p">()):</span>
            <span class="n">inds</span><span class="p">[</span><span class="n">ent</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind</span>

        <span class="c"># create matrix and set blocks on the main diagonal</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">(),)</span><span class="o">*</span><span class="mi">2</span><span class="p">)),</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">tbmat</span><span class="p">())</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">infertype</span><span class="p">())</span>

        <span class="c"># set random potentials and hoppings within the blocks on the main</span>
        <span class="c"># diagonal</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">ent1</span><span class="p">,</span> <span class="n">ent2</span><span class="p">),</span> <span class="n">hop</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>  <span class="c"># new=False</span>
            <span class="c"># define some shortcuts</span>
            <span class="n">ne</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">ents</span><span class="p">()))</span>  <span class="c"># number of entities</span>
            <span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>                     <span class="c"># number of cells</span>

            <span class="c"># generate random variates</span>
            <span class="n">variates</span> <span class="o">=</span> <span class="n">hop</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>

            <span class="c"># add these random hopping parameters to the big matrix</span>
            <span class="n">helper</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">(([</span><span class="mi">1</span><span class="p">],</span> <span class="p">([</span><span class="n">inds</span><span class="p">[</span><span class="n">ent1</span><span class="p">]],</span>
                                              <span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">ent2</span><span class="p">]])),</span>
                                             <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">ne</span><span class="p">,</span> <span class="n">ne</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">diag</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">spdiags</span><span class="p">([</span><span class="n">variates</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
            <span class="n">mat</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">diag</span><span class="p">,</span> <span class="n">helper</span><span class="p">)</span><span class="o">.</span><span class="n">todok</span><span class="p">())</span>
            <span class="c">#mat = mat+scipy.sparse.kron(diag, helper)</span>

            <span class="c">### old method. Problem: &quot;+=&quot; only works with lil</span>
            <span class="c">#self._tbmat[inds[ent1]::ne, inds[ent2]::ne] += spdiags([variates],</span>
                                                                    <span class="c">#[0], size,</span>
                                                                    <span class="c">#size)</span>

        <span class="c"># set off-diagonal blocks with submatrix</span>
        <span class="k">for</span> <span class="n">neigh</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighs</span><span class="p">:</span>
            <span class="c"># get index matrix, indicating the blocks that have to be set to</span>
            <span class="c"># enable hopping for this neighbor interaction</span>
            <span class="n">indmat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indmat</span><span class="p">(</span><span class="n">neigh</span><span class="o">.</span><span class="n">vects</span><span class="p">,</span> <span class="n">positions</span><span class="p">)</span>
            <span class="n">isoindmat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indmat</span><span class="p">(</span><span class="n">neigh</span><span class="o">.</span><span class="n">isovects</span><span class="p">,</span> <span class="n">positions</span><span class="p">)</span>

            <span class="c"># set certain blocks of the big matrix with the hopping matrix of</span>
            <span class="c"># this neighbor interaction object</span>
            <span class="n">submat</span> <span class="o">=</span> <span class="n">neigh</span><span class="o">.</span><span class="n">tbmat</span><span class="p">()</span>
            <span class="n">helper3</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">indmat</span><span class="p">,</span> <span class="n">submat</span><span class="p">)</span><span class="o">.</span><span class="n">todok</span><span class="p">()</span>  <span class="c"># need it</span>
                                                                 <span class="c"># again later</span>
            <span class="c">#mat.update(helper3)</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="n">mat</span> <span class="o">+</span> <span class="n">helper3</span>

            <span class="c"># set certain blocks of the big matrix with the adjoint of this</span>
            <span class="c"># hopping matrix</span>
            <span class="n">adjoint</span> <span class="o">=</span> <span class="n">submat</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span>
            <span class="c">#mat.update(scipy.sparse.kron(isoindmat, adjoint).todok())</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="n">mat</span><span class="o">+</span><span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">isoindmat</span><span class="p">,</span> <span class="n">adjoint</span><span class="p">)</span>

            <span class="c"># add the negative real part of each off-diagonal block to the</span>
            <span class="c"># corresponding diagonal block in the same row</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">diaghops</span><span class="p">:</span>
                <span class="n">add2diag</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">helper3</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">real</span>
                <span class="n">add2mat</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">dok_matrix</span><span class="p">(</span><span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">add2mat</span><span class="o">.</span><span class="n">setdiag</span><span class="p">(</span><span class="n">add2diag</span><span class="p">)</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="n">mat</span><span class="o">-</span><span class="n">add2mat</span>

            <span class="c"># set random matrix elements for this hopping matrix</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">ent1</span><span class="p">,</span> <span class="n">ent2</span><span class="p">),</span> <span class="n">hop</span> <span class="ow">in</span> <span class="n">neigh</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>  <span class="c"># new=False</span>
                <span class="c"># generate random variates</span>
                <span class="n">indmat</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">hop</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">indmat</span><span class="o">.</span><span class="n">nnz</span><span class="p">)</span>
                <span class="n">isoindmat</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">hop</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">isoindmat</span><span class="o">.</span><span class="n">nnz</span><span class="p">)</span>

                <span class="c"># define shortcut</span>
                <span class="n">ne</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unitcell</span><span class="o">.</span><span class="n">ents</span><span class="p">()))</span>  <span class="c"># number of entities</span>

                <span class="c"># add these random hopping parameters to the big matrix</span>
                <span class="n">helper</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">(([</span><span class="mi">1</span><span class="p">],</span> <span class="p">([</span><span class="n">inds</span><span class="p">[</span><span class="n">ent1</span><span class="p">]],</span>
                                                  <span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">ent2</span><span class="p">]])),</span>
                                                 <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">ne</span><span class="p">,</span> <span class="n">ne</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                <span class="n">helper2</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">indmat</span><span class="p">,</span> <span class="n">helper</span><span class="p">)</span><span class="o">.</span><span class="n">todok</span><span class="p">()</span>  <span class="c"># need it</span>
                                                                     <span class="c"># later</span>
                <span class="c">#mat.update(helper2)</span>
                <span class="c">#mat.update(scipy.sparse.kron(isoindmat, helper).todok())</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="n">mat</span> <span class="o">+</span> <span class="n">helper2</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="n">mat</span> <span class="o">+</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">isoindmat</span><span class="p">,</span> <span class="n">helper</span><span class="p">)</span><span class="o">.</span><span class="n">todok</span><span class="p">()</span>

                <span class="c"># add the negative real part of each off-diagonal block to the</span>
                <span class="c"># corresponding diagonal block in the same row</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">diaghops</span><span class="p">:</span>
                    <span class="n">add2diag</span> <span class="o">=</span> \
                        <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">helper2</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">real</span><span class="o">/</span><span class="mi">2</span>
                    <span class="n">add2mat</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">dok_matrix</span><span class="p">(</span><span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                    <span class="n">add2mat</span><span class="o">.</span><span class="n">setdiag</span><span class="p">(</span><span class="n">add2diag</span><span class="p">)</span>
                    <span class="n">mat</span> <span class="o">=</span> <span class="n">mat</span> <span class="o">-</span> <span class="n">add2mat</span>

        <span class="c"># convert to CSR sparse format by default</span>
        <span class="k">if</span> <span class="n">format</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">format</span> <span class="o">=</span> <span class="s">&#39;csr&#39;</span>

        <span class="c"># return matrix</span>
        <span class="k">if</span> <span class="n">distinguish</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mat</span><span class="o">.</span><span class="n">asformat</span><span class="p">(</span><span class="n">format</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">position_classes_ind</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mat</span><span class="o">.</span><span class="n">asformat</span><span class="p">(</span><span class="n">format</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_ndindex2index_old</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndindex</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return index of the given n-dimensional index that it would have in</span>
<span class="sd">        the n-dimensional index list provided by scipy.ndindex. If ndindex is a</span>
<span class="sd">        2D array, each row is treated as an n-dimensional index, and the result</span>
<span class="sd">        will be a 1D array of indices.  Can also be given a list of nd-indices</span>
<span class="sd">        (2d-array).&quot;&quot;&quot;</span>
        <span class="c"># 2012-09-03</span>
        <span class="c"># copied from tb.sc.Lattice.ndindex2index (developed 2011-08-23)</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ndindex</span><span class="p">,</span> <span class="n">scipy</span><span class="o">.</span><span class="n">cumprod</span><span class="p">((</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="o">-</span><span class="mi">2</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="c">### The look-up table could better be calculated once, and not be</span>
        <span class="c">### re-calculated for every vector, because it is universal!</span>

<div class="viewcode-block" id="SparseLattice.ndindex2index"><a class="viewcode-back" href="../../sc.html#tb.sc.SparseLattice.ndindex2index">[docs]</a>    <span class="k">def</span> <span class="nf">ndindex2index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndindex</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return index of the given n-dimensional index that it would have in</span>
<span class="sd">        the n-dimensional index list provided by scipy.ndindex. If ndindex is a</span>
<span class="sd">        2D array, each row is treated as an n-dimensional index, and the result</span>
<span class="sd">        will be a 1D array of indices.&quot;&quot;&quot;</span>
        <span class="c"># 2012-09-03</span>
        <span class="c"># copied from tb.sc.Lattice.ndindex2index (developed 2011-08-23</span>
        <span class="c"># - 2012-09-03)</span>
        <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ndindex</span><span class="p">,</span> <span class="n">scipy</span><span class="o">.</span><span class="n">cumprod</span><span class="p">((</span><span class="mi">1</span><span class="p">,)</span><span class="o">+</span><span class="n">shape</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="o">-</span><span class="mi">2</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="c">### The look-up table could better be calculated once, and not be</span>
        <span class="c">### re-calculated for every vector, because it is universal!</span>


<span class="c"># for compatibility of old HDF5 data files where SuperCell objects were pickled</span>
<span class="c"># can be erased in the future</span></div></div>
<span class="n">uniform</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">uniform</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">tb 0.1 documentation</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li>
          <li><a href="../tb.html" >tb</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Daniel Jung.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>